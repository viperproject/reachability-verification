import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/zopg.vpr"
import "../_preambles/zopg.vpr"


domain newZOPGTCs {
    axiom ax_DEP_0 {
        forall EG: Set[Edge], x0: Ref, y0: Ref, u0: Ref, v0: Ref ::
            {exists_DEP_alias(EG, x0, y0, u0, y0), exists_DEP_alias(EG, x0, y0, v0, y0)}
                u0 != v0 ==> !(exists_DEP_alias(EG, x0, y0, u0, y0) && exists_DEP_alias(EG, x0, y0, v0, y0))
    }
    axiom ax_TailTriangleImposable_Part {
        forall EG: Set[Edge], y0: Ref, u0: Ref ::
            {exists_DEP_alias(EG, y0, y0, u0, y0)}
                edge(EG, u0, y0) && u0 != y0 && exists_path_(EG, y0, u0) ==> exists_DEP_alias(EG, y0, y0, u0, y0)
    }
}

define UNSHARED_CONNECTED(g)
(
    ( forall v1:Ref, v2:Ref, u0:Ref :: 
        { u0 in g, v1.next, v2.next } 
        v1 in g && v2 in g && u0 in g ==> ( v1.next == u0 && v2.next == u0 ==> v1 == v2 ) )
    && ( forall u0:Ref :: 
        { u0.next } 
        u0 in g ==> ( u0 == u0.next <==> g == Set(u0) ) )
)

define RING(graph) ( GRAPH(graph) && COMPLETE(graph) )

method three_opt(g: Set[Ref], u: Ref, x: Ref)// returns (res:Int)
    requires RING(g) //Access permissions + next in g
    requires UNSHARED_CONNECTED(g)
    requires u in g && x in g
    requires u != x && u != x.next && u != x.next.next
    requires u.next != x
    requires u.next.next != x && u.next.next != u
    requires x.next.next != x //Should follow from ring definition?
    requires (forall n: Ref, m: Ref :: {P_(g,n,m)} n in g && m in g ==> P_(g,n,m))
    ensures true
{

    
    var v : Ref := u.next
    var w : Ref := v.next
    var y : Ref := x.next
    var z : Ref := y.next

    //Change from u-->v-->w to u-->y-->w
    //and from    x-->y-->z to x-->v-->z

/*
    //FOR TRIGGERING
    assert forall n0: Ref, m: Ref :: {DEP_(g, n0, m, n0, n0.next)} n0 in g && m in g ==> n0.next in g &&
        E_(g, n0, n0.next) && n0 != n0.next && 
        exists_path($$(g), n0.next, m) ==>  DEP_(g, n0, m, n0, n0.next)
    assert forall n0: Ref :: {DEP_(g, n0, u, u, v)} n0 in g && n0 != u ==> 
    !DEP_(g, n0, u, u, v) && DEP_(g, n0, u, n0, n0.next)
    assert forall n0: Ref :: 
        {DEP_(g, v, n0, u, v)} 
        n0 in g && v != n0 ==> !DEP_(g, v, n0, u, v) && DEP_(g, v, n0, v, w)
*
    unlink_ZOPG_next(g, u)

/*    //FOR TRIGGERING
    assert forall n: Ref :: 
        {P_(g, n, u)} 
        n in g && n != u ==> (DEP_(g, n, u, n, n.next) ==> P_(g, n, u))
    assert forall n: Ref :: 
        {P_(g, v, n)} 
        n in g && n != v ==> (DEP_(g, v, n, v, w) ==> P_(g, v, n))

    //NEEDED INFO AT THIS STATE
    assert forall n: Ref ::
        {P_(g, n, u)}
        n in g ==> P_(g, n, u)
    assert forall n: Ref ::
        {P_(g, v, n)}
        n in g ==> P_(g, v, n)

*

label l1
    link_ZOPG_next(g, u, y)
/*
    //FOR TRIGGERING
    assert forall n: Ref ::
        {P_(g, v, n)}
        n in g && n != v ==> 
            (P1(g, v, n) && DEP1(g, v, n, v, w) && DEP_(g, v, n, v, w)) ==>
                P_(g, v, n)
    //state_l2(g, u, v, w, x, y, z)
    

    /// ATG: this is where we get unsound! 
    //assert false

    /**** 
    The unsoundness can be reproduces with the following definitions of update formulas: 

        method unlink_ZOPG_next(g:Set[Ref], node:Ref)
            requires PROTECTED_GRAPH_next(g,node)
            requires node in g
            ensures PROTECTED_GRAPH_next(g,node)
            ensures node.next == null
            ensures old(node.next) == null ==> $$(g) == old($$(g))
            ensures old(node.next) != null ==> ZOPG_UNLINK__PRECISE_TC_UPDATE_FORMULA(g, node, old(node.next))

        method link_ZOPG_next(g:Set[Ref], from:Ref, to:Ref)
            requires PROTECTED_GRAPH_next(g,from) 
            requires from in g && from.next == null
            requires (to != null) ==> to in g
            ensures PROTECTED_GRAPH_next(g,from)
            ensures from.next == to
            ensures (to == null) ==> $$(g) == old($$(g))
            ensures (to != null) ==> ZOPG_LINK__PRECISE_TC_UPDATE_FORMULA(g, from, to)      

            // Automatic reasoning support
            // a. Arity-independent
            ensures (to != null) ==> forall n:Ref, m:Ref :: 
                { P_(g, n, m) } 
                    n in g && m in g ==> 
                        __learn_trigger__( P_(g, n, to) ) && 
                        __learn_trigger__( P_(g, to, m) )

            // b. Arity-dependent
            ensures forall n0: Ref :: 
                { P_(g, n0, to) }
                { P_(g, n0, from) } 
                    n0 in g && n0 != from ==> __learn_trigger__(DEP_(g, n0, from, n0, n0.next))

    ****


    //NEEDED INFO AT THIS STATE
    assert forall n: Ref ::
        {P_(g, n, u)}{P_(g, n, y)}
        n in g ==> P_(g, n, u) && P_(g, n, y)
    assert forall n: Ref ::
        {P_(g, u, n)}
        n in g && P_(g, y, n) <==> P_(g, u, n)
    assert forall n: Ref ::
        {P_(g, v, n)}
        n in g ==>
            P_(g, v, n)

*/

    unlink_ZOPG_next(g, u)

    //AXIOM
    assume apply_noExit($$(g), g, g setminus Set(v))
    //FOR TRIGGERING
    assert forall n: Ref ::
        {DEP0(g, n, u, n, n.next)}
            n in g && P0(g, n, u) ==> (n == u || (DEP0(g, n, u, n, n.next) && !DEP0(g, n, u, u, v)))
    assert forall n: Ref ::
        {DEP_(g, n, u, n, n.next)}
            n in g && (DEP0(g, n, u, n, n.next) && !DEP0(g, n, u, u, v)) ==> DEP_(g, n, u, n, n.next) 
    assert forall n: Ref ::
        {P_(g, n, u)}
            n in g && DEP_(g, n, u, n, n.next) ==> P_(g, n, u)
    assert forall n: Ref ::
        {DEP0(g, v, n, v, v.next)}
            n in g && P0(g, v, n) ==> (n == v || (DEP0(g, v, n, v, v.next) && !DEP0(g, v, n, u, v)))
    assert forall n: Ref ::
        {DEP_(g, v, n, v, v.next)}
            n in g && (n == v || (DEP0(g, v, n, v, v.next) && !DEP0(g, v, n, u, v))) ==> (n == v || DEP_(g, v, n, v, v.next))
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g && (n == v || DEP_(g, v, n, v, v.next)) ==> P_(g, v, n)
    assert P0(g, v, x) && !DEP0(g, v, x, u, v) && DEP0(g, v, x, v, w) ==> DEP_(g, v, x, v, w)

    //NEEDED INFO
    assert GRAPH(g)
    assert (forall u0: Ref ::
        {u0.next}
            u0 in g && u0 != u ==> u0.next == old(u0.next)) && u.next == null
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g ==> P_(g, v, n)
    assert !P_(g, z, v) && !P_(g, w, v)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, u)}
            n in g ==> P_(g, n, u)


label l1
    link_ZOPG_next(g, u, y)

    //AXIOM
    assume apply_noExit($$(g), g, g setminus Set(v))
    //FOR TRIGGERING
    assert P1(g, w, x) && DEP1(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)
    assert forall n: Ref ::
        {DEP1(g, v, n, v, v.next)}
            n in g && P1(g, v, n) ==> (v == n || DEP1(g, v, n, v, v.next)) 
    assert DEP_(g, z, y, x, y) ==> P_(g, y, x) ==> DEP_(g, y, y, x, y)
    assert forall n: Ref ::
        {DEP1(g, v, n, v, v.next)}
            n in g && P1(g, v, n) ==> (v == n || DEP1(g, v, n, v, v.next)) 
    assert forall n: Ref ::
        {DEP_(g, v, n, v, v.next)}
            n in g && (v == n || DEP1(g, v, n, v, v.next)) ==> (v == n || DEP_(g, v, n, v, v.next))
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g && (v == n || DEP_(g, v, n, v, v.next)) ==> P_(g, v, n)
    assert forall n: Ref ::
        {DEP1(g, n, u, n, n.next)}
            n in g && P1(g, n, u) ==> (u == n || DEP1(g, n, u, n, n.next))
    assert forall n: Ref ::
        {DEP_(g, n, u, n, n.next)}
            n in g && (u == n || DEP1(g, n, u, n, n.next)) ==> (v == n || DEP_(g, n, u, n, n.next))
    assert forall n: Ref ::
        {P_(g, n, u)}
            n in g && (v == n || DEP_(g, n, u, n, n.next)) ==> P_(g, n, u)

    //edge_update(g, u, y)
    //NEEDED INFO
    assert GRAPH(g)
    assert (forall u0: Ref ::
        {u0.next}
            u0 in g && u0 != u ==> u0.next == old(u0.next)) && u.next == y
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g ==> P_(g, v, n)
    assert !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, u)}
            n in g ==> P_(g, n, u)

label l2
    unlink_ZOPG_next(g, y)

    //FOR TRIGGERING
    assert (forall u0: Ref ::
        {u0.next}
            u0 in g && u0 != u && u0 != y ==> u0.next == old(u0.next))
    assert !DEP2(g, z, v, z, z.next) ==> !DEP_(g, z, v, z, z.next)
    assert !DEP2(g, w, v, w, w.next) ==> !DEP_(g, w, v, w, w.next)
    assert forall n: Ref ::
        {P2(g, z, n)}
            DEP2(g, v, n, y, z) ==> P2(g, z, n)
    assert forall n: Ref ::
        {DEP2(g, z, n, z, z.next)}
            P2(g, z, n) ==> (z == n || (!DEP2(g, z, n, y, z) && DEP2(g, z, n, z, z.next)))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
            (z == n || (!DEP2(g, z, n, y, z) && DEP2(g, z, n, z, z.next))) ==> (z == n || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
            DEP_(g, z, n, z, z.next) ==> P_(g, z, n)
    assert forall n: Ref ::
        {DEP2(g, v, n, v, w)}
            n in g && !DEP2(g, v, n, y, z) && P2(g, v, n) ==> (n == v || DEP2(g, v, n, v, w))
    assert forall n: Ref ::
        {DEP_(g, v, n, v, w)}
            n in g && (n == v || (!DEP2(g, v, n, y, z) && DEP2(g, v, n, v, w))) ==> (n == v || DEP_(g, v, n, v, w))
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g && DEP_(g, v, n, v, w) ==> P_(g, v, n)

    assert P2(g, y, u) && E2(g, u, y) && DEP2(g, y, y, u, y) && !DEP2(g, y, y, x, y) && 
           !P2(g, z, x) && !DEP2(g, w, x, y, z) &&  DEP2(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)

    assert forall n: Ref ::
        {P2(g, n, y)}
            n in g ==> P2(g, n, u) && P2(g, u, y)
            
    assert forall n: Ref ::
        {P2(g, n, y)}
            n in g && P2(g, n, u) && P2(g, u, y) ==> P2(g, n, y)
    assert forall n: Ref ::
        {DEP2(g, n, y, n, n.next)}
            n in g && P2(g, n, y) ==> (n == y || !DEP2(g, n, y, y, z))
    assert forall n: Ref ::
        {P2(g, n.next, y)}
            n in g && P2(g, n, y) && n != y && E2(g, n, n.next) ==> P2(g, n.next, y)
    assert forall n: Ref ::
        {DEP2(g, n, y, n, n.next)}
            n in g && P2(g, n, y) && E2(g, n, n.next) && P2(g, n.next, y) ==> DEP2(g, n, y, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, y)}
            n in g && (n == y || (!DEP2(g, n, y, y, z)) && DEP2(g, n, y, n, n.next)) ==>
                (n == y || DEP_(g, n, y, n, n.next))

    //NEEDED INFO
    assert GRAPH(g)
    assert (forall u0: Ref ::
        {u0.next}
            u0 in g && u0 != y && u0 != u ==> (u0.next == old(u0.next)))
    assert u.next == y && y.next == null
    assert forall n: Ref ::
        {P_(g, v, n)}{P_(g, z, n)}
            n in g ==> P_(g, z, n) || P_(g, v, n)
    assert !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, y)}
            n in g ==> P_(g, n, y)
        
label l3
    link_ZOPG_next(g, y, w)

    //FOR TRIGGERING
    assert forall n: Ref :: 
        {P_(g, n, y)}
            n in g && P3(g, n, y) ==> P_(g, n, y)
    assert forall n: Ref ::
        {P3(g, w, n)}
            n in g && P3(g, v, n) ==> v == n || P3(g, w, n)
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && P3(g, w, n) ==> P_(g, w, n)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P3(g, z, n) ==> (z == n || DEP3(g, z, n, z, z.next)) ==> (z == n || DEP_(g, z, n, z, z.next))

    //edge_update(g, u, y)
    //edge_update(g, y, w)

    //NEEDED INFO
    assert GRAPH(g)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g ==> (P_(g, z, n) || n == v)
    assert !DEP_(g, z, w, v, w) && !DEP_(g, z, y, x, y)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g ==> P_(g, n, x)
 
  
label l4
    unlink_ZOPG_next(g, x)

    //FOR TRIGGERING
    assert P4(g, w, x) ==> !DEP4(g, w, x, x, y) && DEP4(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g && P4(g, n, x) && n != x ==> !DEP4(g, n, x, x, y) && DEP4(g, n, x, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g && !DEP4(g, n, x, x, y) && DEP4(g, n, x, n, n.next) ==> DEP_(g, n, x, n, n.next)
    assert forall n: Ref ::
        {P4(g, y, n)}
            n in g && !P4(g, x, n) ==> !P4(g, y, n)
    assert forall n: Ref ::
        {DEP4(g, z, n, x, y)}
            n in g && !P4(g, y, n) ==> !DEP4(g, z, n, x, y)
    assert forall n: Ref ::
        {DEP4(g, z, n, z, z.next)}
            n in g && !DEP4(g, z, n, x, y) && P4(g, z, n) ==> (n == z || DEP4(g, z, n, z, z.next))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
            n in g && !DEP4(g, z, n, x, y) && (n == z || DEP4(g, z, n, z, z.next)) ==> 
                (n == z || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && (n == z || DEP_(g, z, n, z, z.next)) ==> P_(g, z, n)

    assert P4(g, z, y) && !DEP4(g, z, y, x, y) ==> DEP4(g, z, y, z, z.next)
    assert !DEP4(g, z, y, x, y) && !DEP4(g, z, y, z, z.next) ==> DEP_(g, z, y, z, z.next)
    assert DEP_(g, z, y, z, z.next) ==> P_(g, z, y)

    //TODO In stepwise approach, proving "forall n: P4(x, n) ==> P_(z, n)" is not needed.
    //NEEDED INFO
    assert GRAPH(g)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g ==> (P_(g, z, n) || n == v)
    assert !DEP_(g, z, w, v, w)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g ==> P_(g, n, x)

label l5
    link_ZOPG_next(g, x, v)

    //FOR TRIGGERING
    assert !DEP5(g, z, w, v, w) && DEP_(g, z, w, v, w) ==> DEP_(g, z, w, x, v)
    assert !E5(g, x, v) ==> !DEP5(g, z, w, x, v)
    assert P5(g, z, w) ==> DEP5(g, z, w, z, z.next) ==> DEP_(g, z, w, z, z.next)
    assert DEP_(g, z, w, z, z.next) && DEP_(g, z, w, x, v) ==> !DEP5(g, z, w, z, z.next)
    assert P5(g, z, x) ==> P_(g, z, x)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P5(g, z, n) && z != n && DEP5(g, z, n, z, z.next) ==> DEP_(g, z, n, z, z.next)
    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && P5(g, n, x) ==> P_(g, n, x)
    

    //edge_update(g, u, y)
    //edge_update(g, y, w)
    //edge_update(g, x, v)

    //NEEDED INFO
    assert GRAPH(g)
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g ==> P_(g, z, n)
    assert !DEP_(g, z, w, v, w)
    assert P_(g, w, x)
    assert forall n: Ref :: 
        {P_(g, n, v)}
            n in g ==> P_(g, n, v)


label l6
    unlink_ZOPG_next(g, v)

    //FOR TRIGGERING    
    assert forall n: Ref ::
        {P6(g, w, n)}
            n in g && !P6(g, v, n) ==> !P6(g, w, n)
    assert forall n: Ref ::
        {DEP6(g, z, n, v, w)}
            n in g && !P6(g, w, n) ==> !DEP6(g, z, n, v, w)
    assert forall n: Ref ::
        {DEP6(g, z, n, z, z.next)}
            n in g && !DEP6(g, z, n, v, w) && P6(g, z, n) ==> (z == n || DEP6(g, z, n, z, z.next))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
           n in g && !DEP6(g, z, n, v, w) && (z == n || DEP6(g, z, n, z, z.next)) ==> (z == n || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
           n in g && (z == n || DEP_(g, z, n, z, z.next)) ==> P_(g, z, n) 
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g && !P6(g, v, n) ==> P_(g, z, n)

    assert P6(g, w, x) && E6(g, x, v) ==> P6(g, w, v)
    assert forall n: Ref ::
        {P6(g, w, n)}
            n in g && P6(g, v, n) ==> P6(g, w, n)
    assert forall n: Ref ::
        {DEP6(g, w, n, v, w)}{DEP6(g, w, n, w, w.next)}
            n in g && P6(g, w, n) ==> (n == w || (!DEP6(g, w, n, v, w) && DEP6(g, w, n, w, w.next)))
    assert forall n: Ref ::
        {DEP_(g, w, n, w, w.next)}
            n in g && (n == w || (!DEP6(g, w, n, v, w) && DEP6(g, w, n, w, w.next))) ==> (n == w || DEP_(g, w, n, w, w.next))
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && (n == w || DEP_(g, w, n, w, w.next)) ==> P_(g, w, n)
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && P6(g, v, n) ==> P_(g, w, n)

    assert P6(g, z, w) && !DEP6(g, z, w, v, w) ==> DEP6(g, z, w, z, z.next)
    assert !DEP6(g, z, w, v, w) && DEP6(g, z, w, z, z.next) ==> DEP_(g, z, w, z, z.next)
    assert DEP_(g, z, w, z, z.next) ==> P_(g, z, w)
    assert P_(g, z, w)

    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P6(g, v, n) && P_(g, w, n) && P_(g, z, w) ==> P_(g, z, n)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P6(g, v, n) ==> P_(g, z, n)

    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && n != v && P6(g, n, v) && !DEP6(g, n, v, v, old[l6](v.next)) && P6(g, n.next, v) ==> 
                DEP6(g, n, v, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, v)}
        n in g && n != v && !DEP6(g, n, v, v, w) && DEP6(g, n, v, n, n.next) ==> DEP_(g, n, v, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && DEP_(g, n, v, n, n.next) ==> P_(g, n, v)

    //NEEDED INFO
    assert GRAPH(g)
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g ==> P_(g, z, n)

    assert forall n: Ref :: 
        {P_(g, n, v)}
            n in g ==> P_(g, n, v)

label l7
    link_ZOPG_next(g, v, z)

    //FOR TRIGGERING
    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && P7(g, n, v) ==> P_(g, n, v)

    //NEEDED INFO
    assert GRAPH(g)
    assert forall n: Ref ::
     {P_(g, v, n)}
        n in g ==> P_(g, v, n)

    assert forall n: Ref ::
     {P_(g, n, v)}
        n in g ==> P_(g, n, v)

    /*
    */
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false

}

method edge_update(g: Set[Ref], from: Ref, to: Ref)
    requires PROTECTED_GRAPH_next(g, from)
    requires from in g && to in g
    ensures PROTECTED_GRAPH_next(g, from)
    ensures from.next == to