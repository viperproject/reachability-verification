import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/zopg.vpr"
import "../_preambles/zopg.vpr"

define UNSHARED_CONNECTED(g)
(
    ( forall v1:Ref, v2:Ref, v:Ref :: 
        { v in g, v1.next, v2.next } 
        v1 in g && v2 in g && v in g ==> ( v1.next == v && v2.next == v ==> v1 == v2 ) )
    && ( forall v:Ref :: 
        { v.next } 
        v in g ==> ( v == v.next <==> g == Set(v) ) )
)

method three_opt(g: Set[Ref], u: Ref, x: Ref)// returns (res:Int)
    requires RING(g) //Access permissions + next in g
    requires UNSHARED_CONNECTED(g)
    requires u in g && x in g
    requires u != x && u != x.next && u != x.next.next
    requires u.next != x
    requires u.next.next != x && u.next.next != u
    requires x.next.next != x //Should follow from ring definition?
    requires (forall n: Ref, m: Ref :: {P(g,n,m)} n in g && m in g ==> P(g,n,m))
    ensures true
{

    /*assume (forall n: Ref, m:Ref, a:Ref ::
        {DEP($$(g), n, m, a, a.next)} {DEP($$(g), m, n, a, a.next)}
        n in g && m in g && a in g && n != m ==> 
            (DEP($$(g), n, m, a, a.next) || DEP($$(g), m, n, a, a.next)))*/
    
    var v : Ref := u.next
    var w : Ref := v.next
    var y : Ref := x.next
    var z : Ref := y.next
    /*assert u != x && u != x.next && u != x.next.next
    assert u.next != x && u.next != x.next && u.next != x.next.next
    assert u.next.next != x && u.next.next != x.next && u.next.next != x.next.next
    assert u != v && u != w && v != w
    assert x != y && y != z && x != z*/

    //Change from u-->v-->w to u-->y-->w
    //and from    x-->y-->z to x-->v-->z

    /*assert forall n: Ref ::
        {P(g, v, n)}
        n in g ==> P(g, v, n) && DEP($$(g), v, n, v, w)

    assert forall n: Ref ::

        n in g && n != v ==>
                (!DEP($$(g), v, n, u, v))*/
        //assert forall n: Ref :: (n in g && P(g, w, u) && E(g, u, v) && P(g, v, n) && u != v) ==> DEP($$(g), w, n, u, v)
                //assert forall n: Ref :: (n in g && (n == v || n == w)) ==> P(g, w, u) && E(g, u, v) && P(g, v, n) && DEP($$(g), w, n, u, v)                
                /*
    assert P(g, v, w)
    assert DEP($$(g), u, w, u, v) && !DEP($$(g), w, u, u, v)
    assert P(g, y, u)
    assert DEP($$(g), w, u, x, y)*/
    /*assert forall p: Ref, q: Ref :: 
        {DEP($$(g), w, x, p, q)}
        p in g && q in g && DEP($$(g), w, x, p, q) ==> !DEP($$(g), w, q, u, v)*/
    unlink_ZOPG_next(g, u)
    /*assert forall n: Ref ::
        {DEP($$(g), v, n, u, v)}
        n in g && n != v ==> !DEP($$(g), v, n, u, v)
    assert forall n: Ref ::
        {P(g, v, n)}
        n in g ==> (P(g, v, n) || n == v)*/
label l1
    link_ZOPG_next(g, u, y)


label l2
    unlink_ZOPG_next(g, y)
label l3
    link_ZOPG_next(g, y, w)


label l4
    unlink_ZOPG_next(g, x)
label l5
    link_ZOPG_next(g, x, v)


label l6
    unlink_ZOPG_next(g, v)
label l7
    link_ZOPG_next(g, v, z)

    //TODO NEEDED 
    assert forall n: Ref :: {P6(g, v, n)} n in g ==> (P6(g, v, n) ==> n == v || P6(g, w, n)) 
    assert forall n: Ref :: {P7(g, w, n)} n in g ==> (P6(g, w, n) ==> P7(g, w, n)) 
    //TODO NEEDED 
    assert forall n: Ref :: {P7(g, z, n)} n in g ==> (P6(g, z, n) ==> P7(g, z, n) || P7(g, w, n))
    //TODO NEEDED 
    assert P6(g, w,x) ==> P7(g, w,x)
    assert E7(g, x, v)


    //3+
    //assert P(g, u, y) && P(g, y, w)// && P(g, u, w)// && P(g, x, v) && P(g, x, z) && P(g, v, z)
    //assert P(g, v,z) && P7(g, w, v) ==> P(g, w, z)
    /*assert forall n: Ref :: 
        {P(g, w, n)}
            (P7(g,w,z) && n in g && (P7(g,w,n) || P7(g,z,n))) ==> 
            P(g, w, n)*/
    /*assert P(g, u, y) && P(g, y, w) && P(g, x, v) && P(g, v, z)
    assert (forall n: Ref :: {P6(g, w, n)} n in g ==> P6(g, w, n)) ==> (forall n: Ref :: {P(g, w, n)} n in g ==> P(g, w, n))*
    assert forall n: Ref, m: Ref :: {P(g, n, m)} n in g && m in g ==> P(g, n, u)  && P(g, u, m) ==> P(g, n, m)
*/

    //assert P1(g, w, x)
    /*assert (forall n: Ref :: {P(g, u, n)} {P(g,n,u)} n in g ==> P(g, u, n) && P(g, n, u)) ==> 
            (forall n: Ref, m: Ref :: {P(g,n,m)} n in g && m in g ==> P(g, n, u) && P(g, u, m))*/
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
    /*assert P(g, u, y) && P(g, y, w) && P(g, u, w)
    assert (forall n: Ref :: {P(g, w, n)} n != y && n != w && n in g ==> P(g, w, n)) ==> (forall n: Ref :: {P(g, u, n)} n in g ==> P(g, u, n))
    assert (forall n: Ref :: {P(g, u, n)} {P(g, n, u)} n in g ==> P(g, u, n) && P(g, n, u)) ==>
         (forall n: Ref, m: Ref :: {P(g, n, m)} n in g && m in g ==> P(g, n, u) && P(g, u, m) && P(g, n, m))*/
    
    /*assert P(g, y, w) && forall n: Ref :: {P(g, w, n)} n in g ==> P(g, w, n)
    assert P(g, u, y) && forall n: Ref :: {P(g, y, n)} n in g ==> P(g, y, n)
    assert forall n: Ref :: {P(g, u, n)} n in g ==> P(g, u, n)*/

}