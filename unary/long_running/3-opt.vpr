import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/zopg.vpr"
import "../_preambles/zopg.vpr"

define UNSHARED_CONNECTED(g)
(
    ( forall v1:Ref, v2:Ref, v:Ref :: 
        { v in g, v1.next, v2.next } 
        v1 in g && v2 in g && v in g ==> ( v1.next == v && v2.next == v ==> v1 == v2 ) )
    && ( forall v:Ref :: 
        { v.next } 
        v in g ==> ( v == v.next <==> g == Set(v) ) )
)

method three_opt(g: Set[Ref], u: Ref, x: Ref)// returns (res:Int)
    requires RING(g) //Access permissions + next in g
    requires UNSHARED_CONNECTED(g)
    requires u in g && x in g
    requires u != x && u != x.next && u != x.next.next
    requires u.next != x
    requires u.next.next != x && u.next.next != u
    requires x.next.next != x //Should follow from ring definition?
    requires (forall n: Ref, m: Ref :: {P(g,n,m)} n in g && m in g ==> P(g,n,m))
    ensures true
{

    /*assume (forall n: Ref, m:Ref, a:Ref ::
        {DEP($$(g), n, m, a, a.next)} {DEP($$(g), m, n, a, a.next)}
        n in g && m in g && a in g && n != m ==> 
            (DEP($$(g), n, m, a, a.next) || DEP($$(g), m, n, a, a.next)))*/
    
    var v : Ref := u.next
    var w : Ref := v.next
    var y : Ref := x.next
    var z : Ref := y.next
    /*assert u != x && u != x.next && u != x.next.next
    assert u.next != x && u.next != x.next && u.next != x.next.next
    assert u.next.next != x && u.next.next != x.next && u.next.next != x.next.next
    assert u != v && u != w && v != w
    assert x != y && y != z && x != z*/

    //Change from u-->v-->w to u-->y-->w
    //and from    x-->y-->z to x-->v-->z

    /*assert forall n: Ref ::
        {P(g, v, n)}
        n in g ==> P(g, v, n) && DEP($$(g), v, n, v, w)

    assert forall n: Ref ::

        n in g && n != v ==>
                (!DEP($$(g), v, n, u, v))*/
        //assert forall n: Ref :: (n in g && P(g, w, u) && E(g, u, v) && P(g, v, n) && u != v) ==> DEP($$(g), w, n, u, v)
                //assert forall n: Ref :: (n in g && (n == v || n == w)) ==> P(g, w, u) && E(g, u, v) && P(g, v, n) && DEP($$(g), w, n, u, v)                
                /*
    assert P(g, v, w)
    assert DEP($$(g), u, w, u, v) && !DEP($$(g), w, u, u, v)
    assert P(g, y, u)
    assert DEP($$(g), w, u, x, y)*/
    /*assert forall p: Ref, q: Ref :: 
        {DEP($$(g), w, x, p, q)}
        p in g && q in g && DEP($$(g), w, x, p, q) ==> !DEP($$(g), w, q, u, v)*/

    //FOR TRIGGERING
    assert forall n0: Ref, m: Ref :: {DEP($$(g), n0, m, n0, n0.next)} n0 in g && m in g ==> n0.next in g &&
        E(g, n0, n0.next) && n0 != n0.next && 
        exists_path($$(g), n0.next, m) ==>  DEP($$(g), n0, m, n0, n0.next)
    assert forall n0: Ref :: {DEP($$(g), n0, u, u, v)} n0 in g && n0 != u ==> 
    !DEP($$(g), n0, u, u, v) && DEP($$(g), n0, u, n0, n0.next)
    assert forall n0: Ref :: 
        {DEP($$(g), v, n0, u, v)} 
        n0 in g && v != n0 ==> !DEP($$(g), v, n0, u, v) && DEP($$(g), v, n0, v, w)

    unlink_ZOPG_next(g, u)

    //FOR TRIGGERING
    assert forall n: Ref :: 
        {P(g, n, u)} 
        n in g && n != u ==> (DEP($$(g), n, u, n, n.next) ==> P(g, n, u))
    assert forall n: Ref :: 
        {P(g, v, n)} 
        n in g && n != v ==> (DEP($$(g), v, n, v, w) ==> P(g, v, n))

    //NEEDED INFO AT THIS STATE
    assert forall n: Ref ::
        {P(g, n, u)}
        n in g ==> P(g, n, u)
    assert forall n: Ref ::
        {P(g, v, n)}
        n in g ==> P(g, v, n)

label l1
    link_ZOPG_next(g, u, y)

    //FOR TRIGGERING
    assert forall n: Ref ::
        {P(g, v, n)}
        n in g && n != v ==> 
            (P1(g, v, n) && DEP(old[l1]($$(g)), v, n, v, w) && DEP($$(g), v, n, v, w)) ==>
                P(g, v, n)
    //state_l2(g, u, v, w, x, y, z)

    //NEEDED INFO AT THIS STATE
    assert forall n: Ref ::
        {P(g, n, u)}{P(g, n, y)}
        n in g ==> P(g, n, u) && P(g, n, y)
    assert forall n: Ref ::
        {P(g, u, n)}
        n in g && P(g, y, n) <==> P(g, u, n)
    assert forall n: Ref ::
        {P(g, v, n)}
        n in g ==>
            P(g, v, n)


label l2
    unlink_ZOPG_next(g, y)

    //FOR TRIGGERING
    /* //TODO Need more info from here
    assert forall n: Ref :: 

    n in g && P2(g, n, u) && DEP(old[l2]($$(g)), n, u, y, z) ==> P2(g, n, y)*/
    assert forall n: Ref ::
    {P(g, z, n)}
    n in g && P2(g, v, n) && DEP(old[l2]($$(g)), v, n, y, z) ==> !DEP($$(g), v, n, y, z) && P2(g, z, n)
    assert forall n: Ref ::
    {P(g, z, n)}
    n in g && n != z && P2(g, v, n) && DEP(old[l2]($$(g)), v, n, y, z) && !DEP($$(g), v, n, y, z) && P2(g, z, n) && 
        !DEP(old[l2]($$(g)), z, n, y, z) && DEP($$(g), z, n, z, z.next) ==> P(g, z, n)
    assert forall n: Ref ::
    {P(g, z, n)}
    n in g && n != z && P2(g, v, n) && DEP(old[l2]($$(g)), v, n, y, z) ==> P(g, z, n)
    assert forall n: Ref ::
    {P(g, v, n)}
    n in g && v != n && P2(g, v, n) && !DEP(old[l2]($$(g)), v, n, y, z) && DEP($$(g), v, n, v, v.next) ==> P(g, v, n)
    assert forall n: Ref ::
    {P(g, n, y)}
        n in g && n != y && P2(g, n, y) ==> !DEP(old[l2]($$(g)), n, y, y, z) && DEP(old[l2]($$(g)), n, y, n, n.next)
    assert forall n: Ref ::
    {P(g, n, y)}
        n in g && n != y && P2(g, n, y) && !DEP(old[l2]($$(g)), n, y, y, z) && DEP(old[l2]($$(g)), n, y, n, n.next) &&
            DEP($$(g), n, y, n, n.next) ==>  P(g, n, y)
    
    assert P2(g, z, u) && !DEP(old[l2]($$(g)), z, y, y, z) && DEP(old[l2]($$(g)), z, y, z, z.next) ==> 
        DEP($$(g), z, y, z, z.next)
    assert forall n: Ref :: 
        {DEP($$(g), z, y, n, n.next)}
        n in g && DEP(old[l2]($$(g)), z, y, n, n.next) ==> DEP($$(g), z, y, n, n.next)
    assert forall n: Ref :: 
        {DEP($$(g), z, y, n, n.next)}
        n in g && DEP($$(g), z, y, n, n.next) ==> P(g, z, n) && P(g, n, y)

    //NEEDED INFO AT THIS STATE
    assert P(g, u, y) 
    assert forall n: Ref ::
    {P(g, n, y)}
    n in g ==> P(g, n, y)
    assert forall n: Ref :: 
    {P(g, v, n)} {P(g, z, n)}
    n in g ==> P(g, v, n) || P(g, z, n)
    assert P(g, z, y) && P(g, v, y)
    
/*label l3
    link_ZOPG_next(g, y, w)

    assert forall n: Ref ::
    {P(g, n, y)}
    n in g && P3(g, n, y) ==> P(g, n, y)

    assert forall n: Ref ::
    {P(g, v, n)}
    n in g && P3(g, v, n) ==> P(g, v, n)


    assert forall n: Ref ::
    {P(g, z, n)}
    n in g && P3(g, z, n) && z != n ==> DEP(old[l3]($$(g)), z, n, z, z.next) && DEP($$(g), z, n, z, z.next)
    
    assert forall n: Ref ::
    {P(g, z, n)}
    n in g && P3(g, z, n) ==> P(g, z, n)

    assert forall n: Ref ::
    {P(g, z, n)} {P(g, v, n)}
    n in g ==> P(g, z, n) || P(g, v, n)

    assert P(g, z, y)


    assert forall n: Ref ::
    {P(g, n, y)}
    n in g ==> P(g, n, y)*/


    //assert P(g, z, y)

    /*assert forall n: Ref ::

    n in g ==> */

/*label l4
    unlink_ZOPG_next(g, x)
label l5
    link_ZOPG_next(g, x, v)


label l6
    unlink_ZOPG_next(g, v)
label l7
    link_ZOPG_next(g, v, z)

    //TODO NEEDED 
    assert forall n: Ref :: {P6(g, v, n)} n in g ==> (P6(g, v, n) ==> n == v || P6(g, w, n)) 
    assert forall n: Ref :: {P7(g, w, n)} n in g ==> (P6(g, w, n) ==> P7(g, w, n)) 
    //TODO NEEDED 
    assert forall n: Ref :: {P7(g, z, n)} n in g ==> (P6(g, z, n) ==> P7(g, z, n) || P7(g, w, n))
    //TODO NEEDED 
    assert P6(g, w,x) ==> P7(g, w,x)
    assert E7(g, x, v)*/


    //3+
    //assert P(g, u, y) && P(g, y, w)// && P(g, u, w)// && P(g, x, v) && P(g, x, z) && P(g, v, z)
    //assert P(g, v,z) && P7(g, w, v) ==> P(g, w, z)
    /*assert forall n: Ref :: 
        {P(g, w, n)}
            (P7(g,w,z) && n in g && (P7(g,w,n) || P7(g,z,n))) ==> 
            P(g, w, n)*/
    /*assert P(g, u, y) && P(g, y, w) && P(g, x, v) && P(g, v, z)
    assert (forall n: Ref :: {P6(g, w, n)} n in g ==> P6(g, w, n)) ==> (forall n: Ref :: {P(g, w, n)} n in g ==> P(g, w, n))*
    assert forall n: Ref, m: Ref :: {P(g, n, m)} n in g && m in g ==> P(g, n, u)  && P(g, u, m) ==> P(g, n, m)
*/

    //assert P1(g, w, x)
    /*assert (forall n: Ref :: {P(g, u, n)} {P(g,n,u)} n in g ==> P(g, u, n) && P(g, n, u)) ==> 
            (forall n: Ref, m: Ref :: {P(g,n,m)} n in g && m in g ==> P(g, n, u) && P(g, u, m))*/
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
    /*assert P(g, u, y) && P(g, y, w) && P(g, u, w)
    assert (forall n: Ref :: {P(g, w, n)} n != y && n != w && n in g ==> P(g, w, n)) ==> (forall n: Ref :: {P(g, u, n)} n in g ==> P(g, u, n))
    assert (forall n: Ref :: {P(g, u, n)} {P(g, n, u)} n in g ==> P(g, u, n) && P(g, n, u)) ==>
         (forall n: Ref, m: Ref :: {P(g, n, m)} n in g && m in g ==> P(g, n, u) && P(g, u, m) && P(g, n, m))*/
    
    /*assert P(g, y, w) && forall n: Ref :: {P(g, w, n)} n in g ==> P(g, w, n)
    assert P(g, u, y) && forall n: Ref :: {P(g, y, n)} n in g ==> P(g, y, n)
    assert forall n: Ref :: {P(g, u, n)} n in g ==> P(g, u, n)*/

}

method state_l2(g:Set[Ref], u: Ref, v: Ref, w: Ref, x: Ref, y: Ref, z: Ref)
    requires PROTECTED_GRAPH(g, u)
    requires u in g && y in g
    ensures PROTECTED_GRAPH(g, u)
    ensures u.next == y