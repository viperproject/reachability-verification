import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/zopg.vpr"
import "../_preambles/zopg.vpr"


domain newZOPGTCs {
    axiom ax_DEP_0 {
        forall EG: Set[Edge], x0: Ref, y0: Ref, u0: Ref, v0: Ref ::
            {exists_DEP_alias(EG, x0, y0, u0, y0), exists_DEP_alias(EG, x0, y0, v0, y0)}
                u0 != v0 ==> !(exists_DEP_alias(EG, x0, y0, u0, y0) && exists_DEP_alias(EG, x0, y0, v0, y0))
    }
    axiom ax_TailTriangleImposable_Part {
        forall EG: Set[Edge], y0: Ref, u0: Ref ::
            {exists_DEP_alias(EG, y0, y0, u0, y0)}
                edge(EG, u0, y0) && u0 != y0 && exists_path_(EG, y0, u0) ==> exists_DEP_alias(EG, y0, y0, u0, y0)
    }
}

define UNSHARED_CONNECTED(g)
(
    ( forall v1:Ref, v2:Ref, u0:Ref :: 
        { u0 in g, v1.next, v2.next } 
        v1 in g && v2 in g && u0 in g ==> ( v1.next == u0 && v2.next == u0 ==> v1 == v2 ) )
    && ( forall u0:Ref :: 
        { u0.next } 
        u0 in g ==> ( u0 == u0.next <==> g == Set(u0) ) )
)

define RING(graph) ( GRAPH(graph) && COMPLETE(graph) )

define not_equal(u, v, w, x, y, z)
( u != v && u != w && v != w &&
  x != y && x != z && z != y &&
  x != u && x != v && x != w &&
  y != u && y != v && y != w &&
  z != u && z != v && z != w
)

method three_opt_sigma0_to2(g: Set[Ref], u: Ref, v: Ref, w: Ref, x: Ref, y: Ref, z: Ref)
    requires PROTECTED_GRAPH_next(g, u)
    requires COMPLETE(g)
    requires UNSHARED_CONNECTED(g)
    requires u in g && v in g && w in g && x in g && y in g && z in g
    requires not_equal(u,v,w,x,y,z)
    requires u.next == v && v.next == w && x.next == y && y.next == z
    requires (forall n: Ref, m: Ref :: {P_(g,n,m)} n in g && m in g ==> P_(g,n,m))
    ensures PROTECTED_GRAPH_next(g, u)
    ensures u.next == y
    ensures forall n_0: Ref ::
        {P_(g, v, n_0)}
            n_0 in g ==> P_(g, v, n_0)
    ensures !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    ensures P_(g, w, x)
    ensures forall n_0: Ref ::
        {P_(g, n_0, u)}
            n_0 in g ==> P_(g, n_0, u)
{
        unlink_ZOPG_next(g, u)

    //AXIOM
    assume apply_noExit($$(g), g, g setminus Set(v))
    //FOR TRIGGERING
    assert forall n_0: Ref ::
        {DEP0(g, n_0, u, n_0, n_0.next)}
            n_0 in g && P0(g, n_0, u) ==> (n_0 == u || (DEP0(g, n_0, u, n_0, n_0.next) && !DEP0(g, n_0, u, u, v)))
    assert forall n_0: Ref ::
        {DEP_(g, n_0, u, n_0, n_0.next)}
            n_0 in g && (DEP0(g, n_0, u, n_0, n_0.next) && !DEP0(g, n_0, u, u, v)) ==> DEP_(g, n_0, u, n_0, n_0.next) 
    assert forall n_0: Ref ::
        {P_(g, n_0, u)}
            n_0 in g && DEP_(g, n_0, u, n_0, n_0.next) ==> P_(g, n_0, u)
    assert forall n_0: Ref ::
        {DEP0(g, v, n_0, v, v.next)}
            n_0 in g && P0(g, v, n_0) ==> (n_0 == v || (DEP0(g, v, n_0, v, v.next) && !DEP0(g, v, n_0, u, v)))
    assert forall n_0: Ref ::
        {DEP_(g, v, n_0, v, v.next)}
            n_0 in g && (n_0 == v || (DEP0(g, v, n_0, v, v.next) && !DEP0(g, v, n_0, u, v))) ==> (n_0 == v || DEP_(g, v, n_0, v, v.next))
    assert forall n_0: Ref ::
        {P_(g, v, n_0)}
            n_0 in g && (n_0 == v || DEP_(g, v, n_0, v, v.next)) ==> P_(g, v, n_0)
    assert P0(g, v, x) && !DEP0(g, v, x, u, v) && DEP0(g, v, x, v, w) ==> DEP_(g, v, x, v, w)

    //NEEDED INFO
    assert forall n_0: Ref ::
        {P_(g, v, n_0)}
            n_0 in g ==> P_(g, v, n_0)
    assert !P_(g, z, v) && !P_(g, w, v)
    assert P_(g, w, x)
    assert forall n_0: Ref ::
        {P_(g, n_0, u)}
            n_0 in g ==> P_(g, n_0, u)


label l1
    link_ZOPG_next(g, u, y)

    //AXIOM
    assume apply_noExit($$(g), g, g setminus Set(v))
    //FOR TRIGGERING
    assert P1(g, w, x) && DEP1(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)
    assert forall n_0: Ref ::
        {DEP1(g, v, n_0, v, v.next)}
            n_0 in g && P1(g, v, n_0) ==> (v == n_0 || DEP1(g, v, n_0, v, v.next)) 
    assert DEP_(g, z, y, x, y) ==> P_(g, y, x) ==> DEP_(g, y, y, x, y)
    assert forall n_0: Ref ::
        {DEP1(g, v, n_0, v, v.next)}
            n_0 in g && P1(g, v, n_0) ==> (v == n_0 || DEP1(g, v, n_0, v, v.next)) 
    assert forall n_0: Ref ::
        {DEP_(g, v, n_0, v, v.next)}
            n_0 in g && (v == n_0 || DEP1(g, v, n_0, v, v.next)) ==> (v == n_0 || DEP_(g, v, n_0, v, v.next))
    assert forall n_0: Ref ::
        {P_(g, v, n_0)}
            n_0 in g && (v == n_0 || DEP_(g, v, n_0, v, v.next)) ==> P_(g, v, n_0)
    assert forall n_0: Ref ::
        {DEP1(g, n_0, u, n_0, n_0.next)}
            n_0 in g && P1(g, n_0, u) ==> (u == n_0 || DEP1(g, n_0, u, n_0, n_0.next))
    assert forall n_0: Ref ::
        {DEP_(g, n_0, u, n_0, n_0.next)}
            n_0 in g && (u == n_0 || DEP1(g, n_0, u, n_0, n_0.next)) ==> (v == n_0 || DEP_(g, n_0, u, n_0, n_0.next))
    assert forall n_0: Ref ::
        {P_(g, n_0, u)}
            n_0 in g && (v == n_0 || DEP_(g, n_0, u, n_0, n_0.next)) ==> P_(g, n_0, u)

    //edge_update(g, u, y)
    //NEEDED INFO
    // assert forall n_0: Ref ::
    //     {P_(g, v, n_0)}
    //         n_0 in g ==> P_(g, v, n_0)
    // assert !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    // assert P_(g, w, x)
    // assert forall n_0: Ref ::
    //     {P_(g, n_0, u)}
    //         n_0 in g ==> P_(g, n_0, u)
}

method three_opt_sigma2_to4(g: Set[Ref], u: Ref, v: Ref, w: Ref, x: Ref, y: Ref, z: Ref)
    requires PROTECTED_GRAPH_next(g, y)
    requires u in g && v in g && w in g && x in g && y in g && z in g
    requires not_equal(u,v,w,x,y,z)
    requires u.next == y && v.next == w && x.next == y && y.next == z
    requires forall n_0: Ref ::
        {P_(g, v, n_0)}
            n_0 in g ==> P_(g, v, n_0)
    requires !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    requires P_(g, w, x)
    requires forall n_0: Ref ::
        {P_(g, n_0, u)}
            n_0 in g ==> P_(g, n_0, u)
    ensures PROTECTED_GRAPH_next(g, y)
    ensures y.next == w
    
method three_opt_sigma4_to6(g: Set[Ref], u: Ref, v: Ref, w: Ref, x: Ref, y: Ref, z: Ref)
    requires PROTECTED_GRAPH_next(g, x)
    requires u in g && v in g && w in g && x in g && y in g && z in g
    requires not_equal(u,v,w,x,y,z)
    requires u.next == y && v.next == w && x.next == y && y.next == w
    ensures PROTECTED_GRAPH_next(g, x)
    ensures x.next == v
    
method three_opt_sigma6_to8(g: Set[Ref], u: Ref, v: Ref, w: Ref, x: Ref, y: Ref, z: Ref)
    requires PROTECTED_GRAPH_next(g, v)
    requires u in g && v in g && w in g && x in g && y in g && z in g
    requires not_equal(u,v,w,x,y,z)
    requires u.next == y && v.next == w && x.next == v && y.next == w
    ensures PROTECTED_GRAPH_next(g, v)
    ensures v.next == z


method three_opt(g: Set[Ref], u: Ref, x: Ref)// returns (res:Int)
    requires RING(g) //Access permissions + next in g
    requires UNSHARED_CONNECTED(g)
    requires u in g && x in g
    requires u != x && u != x.next && u != x.next.next
    requires u.next != x
    requires u.next.next != x && u.next.next != u
    requires x.next.next != x //Should follow from ring definition?
    requires (forall n: Ref, m: Ref :: {P_(g,n,m)} n in g && m in g ==> P_(g,n,m))
    ensures true
{

    
    var v : Ref := u.next
    var w : Ref := v.next
    var y : Ref := x.next
    var z : Ref := y.next

    three_opt_sigma0_to2(g, u, v, w, x, y, z)
    three_opt_sigma2_to4(g, u, v, w, x, y, z)
    three_opt_sigma4_to6(g, u, v, w, x, y, z)
    three_opt_sigma6_to8(g, u, v, w, x, y, z)


/*
label l2
    unlink_ZOPG_next(g, y)

    //FOR TRIGGERING
    assert !DEP2(g, z, v, z, z.next) ==> !DEP_(g, z, v, z, z.next)
    assert !DEP2(g, w, v, w, w.next) ==> !DEP_(g, w, v, w, w.next)
    assert forall n: Ref ::
        {P2(g, z, n)}
            DEP2(g, v, n, y, z) ==> P2(g, z, n)
    assert forall n: Ref ::
        {DEP2(g, z, n, z, z.next)}
            P2(g, z, n) ==> (z == n || (!DEP2(g, z, n, y, z) && DEP2(g, z, n, z, z.next)))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
            (z == n || (!DEP2(g, z, n, y, z) && DEP2(g, z, n, z, z.next))) ==> (z == n || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
            DEP_(g, z, n, z, z.next) ==> P_(g, z, n)
    assert forall n: Ref ::
        {DEP2(g, v, n, v, w)}
            n in g && !DEP2(g, v, n, y, z) && P2(g, v, n) ==> (n == v || DEP2(g, v, n, v, w))
    assert forall n: Ref ::
        {DEP_(g, v, n, v, w)}
            n in g && (n == v || (!DEP2(g, v, n, y, z) && DEP2(g, v, n, v, w))) ==> (n == v || DEP_(g, v, n, v, w))
    assert forall n: Ref ::
        {P_(g, v, n)}
            n in g && DEP_(g, v, n, v, w) ==> P_(g, v, n)

    assert P2(g, y, u) && E2(g, u, y) && DEP2(g, y, y, u, y) && !DEP2(g, y, y, x, y) && 
           !P2(g, z, x) && !DEP2(g, w, x, y, z) &&  DEP2(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)

    assert forall n: Ref ::
        {P2(g, n, y)}
            n in g ==> P2(g, n, u) && P2(g, u, y)
            
    assert forall n: Ref ::
        {P2(g, n, y)}
            n in g && P2(g, n, u) && P2(g, u, y) ==> P2(g, n, y)
    assert forall n: Ref ::
        {DEP2(g, n, y, n, n.next)}
            n in g && P2(g, n, y) ==> (n == y || (!DEP2(g, n, y, y, z)) && DEP2(g, n, y, n, n.next))
    assert forall n: Ref ::
        {P_(g, n, y)}
            n in g && (n == y || (!DEP2(g, n, y, y, z)) && DEP2(g, n, y, n, n.next)) ==>
                (n == y || DEP_(g, n, y, n, n.next))

    //NEEDED INFO
    assert forall n: Ref ::
        {P_(g, v, n)}{P_(g, z, n)}
            n in g ==> P_(g, z, n) || P_(g, v, n)
    assert !P_(g, z, v) && !P_(g, w, v) && !DEP_(g, z, y, x, y)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, y)}
            n in g ==> P_(g, n, y)
        
label l3
    link_ZOPG_next(g, y, w)

    //FOR TRIGGERING
    assert forall n: Ref :: 
        {P_(g, n, y)}
            n in g && P3(g, n, y) ==> P_(g, n, y)
    assert forall n: Ref ::
        {P3(g, w, n)}
            n in g && P3(g, v, n) ==> v == n || P3(g, w, n)
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && P3(g, w, n) ==> P_(g, w, n)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P3(g, z, n) ==> (z == n || DEP3(g, z, n, z, z.next)) ==> (z == n || DEP_(g, z, n, z, z.next))

    //NEEDED INFO
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g ==> (P_(g, z, n) || n == v)
    assert !DEP_(g, z, w, v, w) && !DEP_(g, z, y, x, y)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g ==> P_(g, n, x)
   
label l4
    unlink_ZOPG_next(g, x)

    //FOR TRIGGERING
    assert P4(g, w, x) ==> !DEP4(g, w, x, x, y) && DEP4(g, w, x, w, w.next) ==> DEP_(g, w, x, w, w.next)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g && P4(g, n, x) && n != x ==> !DEP4(g, n, x, x, y) && DEP4(g, n, x, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g && !DEP4(g, n, x, x, y) && DEP4(g, n, x, n, n.next) ==> DEP_(g, n, x, n, n.next)
    assert forall n: Ref ::
        {P4(g, y, n)}
            n in g && !P4(g, x, n) ==> !P4(g, y, n)
    assert forall n: Ref ::
        {DEP4(g, z, n, x, y)}
            n in g && !P4(g, y, n) ==> !DEP4(g, z, n, x, y)
    assert forall n: Ref ::
        {DEP4(g, z, n, z, z.next)}
            n in g && !DEP4(g, z, n, x, y) && P4(g, z, n) ==> (n == z || DEP4(g, z, n, z, z.next))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
            n in g && !DEP4(g, z, n, x, y) && (n == z || DEP4(g, z, n, z, z.next)) ==> 
                (n == z || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && (n == z || DEP_(g, z, n, z, z.next)) ==> P_(g, z, n)

    assert P4(g, z, y) && !DEP4(g, z, y, x, y) ==> DEP4(g, z, y, z, z.next)
    assert !DEP4(g, z, y, x, y) && !DEP4(g, z, y, z, z.next) ==> DEP_(g, z, y, z, z.next)
    assert DEP_(g, z, y, z, z.next) ==> P_(g, z, y)

    //TODO In stepwise approach, proving "forall n: P4(x, n) ==> P_(z, n)" is not needed.
    //NEEDED INFO
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g ==> (P_(g, z, n) || n == v)
    assert !DEP_(g, z, w, v, w)
    assert P_(g, w, x)
    assert forall n: Ref ::
        {P_(g, n, x)}
            n in g ==> P_(g, n, x)

label l5
    link_ZOPG_next(g, x, v)

    //FOR TRIGGERING
    assert P5(g, z, x) ==> P_(g, z, x)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P5(g, z, n) && z != n && DEP5(g, z, n, z, z.next) ==> DEP_(g, z, n, z, z.next)
    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && P5(g, n, x) ==> P_(g, n, x)
    
    //NEEDED INFO
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g ==> P_(g, z, n)
    assert !DEP_(g, z, w, v, w)
    assert P_(g, w, x)
    assert forall n: Ref :: 
        {P_(g, n, v)}
            n in g ==> P_(g, n, v)
label l6
    unlink_ZOPG_next(g, v)

    //FOR TRIGGERING    
    assert forall n: Ref ::
        {P6(g, w, n)}
            n in g && !P6(g, v, n) ==> !P6(g, w, n)
    assert forall n: Ref ::
        {DEP6(g, z, n, v, w)}
            n in g && !P6(g, w, n) ==> !DEP6(g, z, n, v, w)
    assert forall n: Ref ::
        {DEP6(g, z, n, z, z.next)}
            n in g && !DEP6(g, z, n, v, w) && P6(g, z, n) ==> (z == n || DEP6(g, z, n, z, z.next))
    assert forall n: Ref ::
        {DEP_(g, z, n, z, z.next)}
           n in g && !DEP6(g, z, n, v, w) && (z == n || DEP6(g, z, n, z, z.next)) ==> (z == n || DEP_(g, z, n, z, z.next))
    assert forall n: Ref ::
        {P_(g, z, n)}
           n in g && (z == n || DEP_(g, z, n, z, z.next)) ==> P_(g, z, n) 
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g && !P6(g, v, n) ==> P_(g, z, n)

    assert P6(g, w, x) && E6(g, x, v) ==> P6(g, w, v)
    assert forall n: Ref ::
        {P6(g, w, n)}
            n in g && P6(g, v, n) ==> P6(g, w, n)
    assert forall n: Ref ::
        {DEP6(g, w, n, v, w)}{DEP6(g, w, n, w, w.next)}
            n in g && P6(g, w, n) ==> (n == w || (!DEP6(g, w, n, v, w) && DEP6(g, w, n, w, w.next)))
    assert forall n: Ref ::
        {DEP_(g, w, n, w, w.next)}
            n in g && (n == w || (!DEP6(g, w, n, v, w) && DEP6(g, w, n, w, w.next))) ==> (n == w || DEP_(g, w, n, w, w.next))
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && (n == w || DEP_(g, w, n, w, w.next)) ==> P_(g, w, n)
    assert forall n: Ref ::
        {P_(g, w, n)}
            n in g && P6(g, v, n) ==> P_(g, w, n)

    assert P6(g, z, w) && !DEP6(g, z, w, v, w) ==> DEP6(g, z, w, z, z.next)
    assert !DEP6(g, z, w, v, w) && DEP6(g, z, w, z, z.next) ==> DEP_(g, z, w, z, z.next)
    assert DEP_(g, z, w, z, z.next) ==> P_(g, z, w)
    assert P_(g, z, w)

    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P6(g, v, n) && P_(g, w, n) && P_(g, z, w) ==> P_(g, z, n)
    assert forall n: Ref ::
        {P_(g, z, n)}
            n in g && P6(g, v, n) ==> P_(g, z, n)

    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && n != v && P6(g, n, v) && !DEP6(g, n, v, v, old[l6](v.next)) && P6(g, n.next, v) ==> 
                DEP6(g, n, v, n, n.next)
    assert forall n: Ref ::
        {P_(g, n, v)}
        n in g && n != v && !DEP6(g, n, v, v, w) && DEP6(g, n, v, n, n.next) ==> DEP_(g, n, v, n, n.next) && P_(g, n, v)

    //NEEDED INFO
    assert forall n: Ref :: 
        {P_(g, z, n)}
            n in g ==> P_(g, z, n)

    assert forall n: Ref :: 
        {P_(g, n, v)}
            n in g ==> P_(g, n, v)

label l7
    link_ZOPG_next(g, v, z)

    //FOR TRIGGERING
    assert forall n: Ref ::
        {P_(g, n, v)}
            n in g && P7(g, n, v) ==> P_(g, n, v)

    //NEEDED INFO
    assert forall n: Ref ::
     {P_(g, v, n)}
        n in g ==> P_(g, v, n)

    assert forall n: Ref ::
     {P_(g, n, v)}
        n in g ==> P_(g, n, v)

    /*
    */
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false

}

method edge_update(g: Set[Ref], from: Ref, to: Ref)
    requires PROTECTED_GRAPH_next(g, from)
    requires from in g && to in g
    ensures PROTECTED_GRAPH_next(g, from)
    ensures from.next == to