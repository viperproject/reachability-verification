import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/zopg.vpr"
import "../_preambles/zopg.vpr"


method swap(g:Set[Ref], x:Ref, i:Int, j:Int)
    // value parameters
    requires 0 <= i && i < j

    // memory safety
    requires x in g
    requires GRAPH(g) && CLOSED(g)

    // reachability
    requires ACYCLIC_LIST_SEGMENT(g)
    requires GLOBAL_ROOT(g,x)
{
    var count:Int := 0

    var prev_node:Ref := x
    var node:Ref := x.next

    var prev_i:Ref := null
    var node_i:Ref := null

    while ( node != null && count <= j )
        // value parameters
        invariant 0 <= i && i < j

        // counter variables
        invariant 0 <= count

        // memory safety
        invariant x in g
        invariant GRAPH(g) && CLOSED(g)

        // nodes
        invariant node != null ==> node in g
        invariant count <= j ==> prev_node in g
        invariant i < count ==> node_i in g && prev_i in g
        invariant count <= j ==> prev_node.next == node

        // triggering
        //invariant node != null ==> exists_path($$(g),node,node) && exists_path($$(g),prev_node,node)


        // reachability
        invariant ACYCLIC_LIST_SEGMENT(g)
        invariant GLOBAL_ROOT(g,x)

        invariant node_i != null ==> exists_path($$(g),prev_i,node_i)
        invariant node_i != null ==> exists_path($$(g),node_i,prev_node)
        invariant node != null ==> exists_path($$(g),prev_node,node)
    {

        //assert false


        // phase i: count < i
        if ( count == i )
        {
            // phase ii: count == i
            node_i := node
            prev_i := prev_node
        }
        // phase iii: i < count < j
        if ( count == j )
        {
            // phase iv: count == j
            var node_j:Ref := node
            var prev_j:Ref := prev_node
            var exit:Ref := node_j.next

            // -- swap node_i and node_j --

            //prev_i.next := node_j
            unlink_ZOPG_next(g,prev_i)
            link_ZOPG_next(g,prev_i,node_j)
            if ( node_i.next != node_j ) {
                // node_j.next := node_i.next
                unlink_ZOPG_next(g,node_j)
                link_ZOPG_next(g,node_j,node_i.next)
                // prev_j.next := node_i
                unlink_ZOPG_next(g,prev_j)
                link_ZOPG_next(g,prev_j,node_i)

            } else { // node_i == prev_j
                //node_j.next := node_i
                unlink_ZOPG_next(g,node_j)
                  link_ZOPG_next(g,node_j,node_i)
            }
            //node_i.next := exit
            unlink_ZOPG_next(g,node_i)
              link_ZOPG_next(g,node_i,exit)
        }

        prev_node := node
        node := node.next
        count := count + 1

        // why can this not be moved to the invariant? :-(
        // or it can be moved, but with 3x perf drop
        // assert node != null ==> exists_path($$(g),node,node) && exists_path($$(g),prev_node,node)
    }
}