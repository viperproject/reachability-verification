import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"


method test_union(g0:Set[Ref], g1:Set[Ref], x0:Ref, x1:Ref) returns (x:Ref)
    requires GRAPH(g0) && CLOSED(g0)
    requires GRAPH(g1) && CLOSED(g1)
    requires x0 in g0
    requires x1 in g1
    requires disjoint(g0,g1)
    requires is_global_root(g0,x0)
    requires is_global_root(g1,x1)

    requires acyclic_list_segment(g0)
    requires acyclic_list_segment(g1)
{
    assume apply_TCFraming(g0,g1)
    //assert forall to:Ref :: to in (g0 union g1) ==> exists from:Ref :: from in Set(x0,x1) && exists_path($$(g0 union g1),from,to)
    //assert forall to:Ref :: to in (g0 union g1) ==> exists from:Ref :: from in Set(x0,x1) && exists_path($$(g0 union g1),from,to)


    //assert forall v1:Ref, v2:Ref :: v1 in g0 && v2 in g1 ==> !edge($$(g0 union g1),v1,v2) || !exists_path($$(g0 union g1),v2,v1)
    //assert forall v1:Ref, v2:Ref :: v1 in g0 && v2 in g0 ==> !edge($$(g0 union g1),v1,v2) || !exists_path($$(g0 union g1),v2,v1)
    assert acyclic(g0 union g1)
    assert functional(g0 union g1)

    //Needed for proving acyclic_list_segment
    assert forall v1: Ref, v2:Ref ::
        { E_(g0 union g1, v1, v2) }
            E_(g0 union g1, v1, v2) ==> 
                E_(g0, v1, v2) || E_(g1, v1, v2)

    //Post conditions
    assert GRAPH(g0 union g1)
    assert is_global_sroot(g0 union g1,Set(x0,x1))

    assert acyclic_list_segment(g0 union g1)


    assert disjoint(g0,g1)

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}

