import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"


method test_union(g0:Set[Ref], g1:Set[Ref], x0:Ref, x1:Ref) returns (x:Ref)
    requires GRAPH(g0) && CLOSED(g0)
    requires GRAPH(g1) && CLOSED(g1)
    requires x0 in g0
    requires x1 in g1
    requires DISJOINT(g0,g1)
    requires GLOBAL_ROOT(g0,x0)
    requires GLOBAL_ROOT(g1,x1)

    requires ACYCLIC_LIST_SEGMENT(g0)
    requires ACYCLIC_LIST_SEGMENT(g1)
{
    assume apply_TCFraming(g0,g1)
    //assert forall to:Ref :: to in (g0 union g1) ==> exists from:Ref :: from in Set(x0,x1) && exists_path($$(g0 union g1),from,to)
    //assert forall to:Ref :: to in (g0 union g1) ==> exists from:Ref :: from in Set(x0,x1) && exists_path($$(g0 union g1),from,to)


    //assert forall v1:Ref, v2:Ref :: v1 in g0 && v2 in g1 ==> !edge($$(g0 union g1),v1,v2) || !exists_path($$(g0 union g1),v2,v1)
    //assert forall v1:Ref, v2:Ref :: v1 in g0 && v2 in g0 ==> !edge($$(g0 union g1),v1,v2) || !exists_path($$(g0 union g1),v2,v1)
    assert ACYCLIC(g0 union g1)
    assert FUNCTIONAL(g0 union g1)

    //Needed for proving ACYCLIC_LIST_SEGMENT
    assert forall v1: Ref, v2:Ref ::
        { E_(g0 union g1, v1, v2) }
            E_(g0 union g1, v1, v2) ==> 
                E_(g0, v1, v2) || E_(g1, v1, v2)

    //Post conditions
    assert GRAPH(g0 union g1)
    assert GLOBAL_SROOT(g0 union g1,Set(x0,x1))

    assert ACYCLIC_LIST_SEGMENT(g0 union g1)


    assert DISJOINT(g0,g1)

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}

