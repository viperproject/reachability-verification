import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../_preambles/memspecs.vpr"
import "../../_preambles/common/graph.vpr"
import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"


method append(g:Set[Ref], x:Ref, y:Ref) returns (res:Ref, last:Ref)

    requires GRAPH(g)
    requires x in g && y in g && x != y

    requires forall n:Ref :: n in g ==> ( exists_path($$(g),x,n) ||  exists_path($$(g),y,n))
    requires forall n:Ref :: n in g ==> (!exists_path($$(g),x,n) || !exists_path($$(g),y,n))

    requires acyclic_graph($$(g))
    requires func_graph($$(g))
    requires unshared_graph($$(g))

    ensures GRAPH(g)

    ensures acyclic_graph($$(g))
    ensures func_graph($$(g))
    ensures unshared_graph($$(g))

    ensures forall u:Ref, v:Ref :: { edge($$(g),u,v) } edge($$(g),u,v) <==> edge(old($$(g)),u,v) || (u==last && v==y)
    ensures forall u:Ref :: { exists_path($$(g),res,u) } exists_path($$(g),res,u) <==> exists_path(old($$(g)),x,u) || exists_path(old($$(g)),y,u)

{
    last := x

    if ( last == null ) { 

        res := y
    
    } else { 
    
        while ( last.next != null ) 
            invariant GRAPH(g)
            invariant last in g
            invariant x in g && y in g

            invariant forall n:Ref :: n in g ==> ( exists_path($$(g),x,n) ||  exists_path($$(g),y,n))
            invariant forall n:Ref :: n in g ==> (!exists_path($$(g),x,n) || !exists_path($$(g),y,n))

            invariant acyclic_graph($$(g))
            //invariant func_graph($$(g))
            invariant unshared_graph($$(g))

            invariant $$(g) == old($$(g))

            // Introducing the whitnesses for the existential quantifiers: 
            invariant exists_path($$(g),x,last)
                      && ( last.next != null ==> edge($$(g),last,last.next) && exists_path($$(g),last.next,last.next) ==> exists_path($$(g),last,last.next) )
        {
            last := last.next
            // assert false
        }


        //last.next := y
        link_DAG_next(g,last,y)

        // Negated definition of TC[f] and the follow-up lemma 
        assert forall u:Ref, v:Ref :: !exists_path($$(g),u,v) ==> u != v && forall w:Ref :: !edge($$(g),u,w) || !exists_path($$(g),w,v)
        assert forall u:Ref, v:Ref :: { edge($$(g),u,v) } !exists_path($$(g),u,v) ==> !edge($$(g),u,v)
    }
    res := x

    // assert func_graph($$(g))
    // assert acyclic_graph($$(g))
    // assert unshared_graph($$(g))

    // assert forall u:Ref :: exists_path($$(g),res,u) <==> exists_path(old($$(g)),x,u) || exists_path(old($$(g)),y,u)
    // assert forall u:Ref, v:Ref :: edge($$(g),u,v) <==> edge(old($$(g)),u,v) || (u==last && v==y)

    // assert false
}
