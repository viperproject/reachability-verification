import "../../../_preambles/TrCloDomain.vpr"
import "../../../_preambles/TrCloZopgDomain.vpr"

import "../../../_preambles/framing.vpr"
import "../../../_preambles/legoFraming.vpr"

import "../../../_preambles/memspecs.vpr"
import "../../_preambles/memspecs.vpr"
import "../../../_preambles/common/graph.vpr"
import "../../../_preambles/common/zopg.vpr"
import "../../_preambles/zopg.vpr"


import "../../../_preambles/macros.vpr"



define UNSHARED_CONNECTED(g)
    ( forall v1:Ref, v2:Ref, v:Ref :: { v in g, v1.next, v2.next } v1 in g && v2 in g && v in g ==> ( v1.next == v && v2.next == v ==> v1 == v2 ) )
    && ( forall v:Ref :: { v.next } v in g ==> ( v == v.next <==> g == Set(v) ) )

define RING(g)
    ( GRAPH(g) && COMPLETE(g) )

method create_node(graph: Set[Ref]) returns (new_graph: Set[Ref], new_node: Ref)
    ensures !( new_node in graph )
    ensures new_graph == graph union Set(new_node)
    ensures acc(new_node.next) 
    ensures new_node.next == null
// {
//     new_node := new(*)
//     assume !( new_node in graph )
//     new_node.next := null
//     new_node.val := init_val
//     new_graph := graph union Set(new_node)
// }


// domain FunnilyEnough {
//     function fummy(n:Ref): Bool
//     function blabla(x:Ref): Bool
//     function theCheckCheck(y:Ref): Bool

//     axiom ax_Foo{
//         forall m: Ref :: 
//             { fummy(m) }
//                 false
//     }
// }

method ringInsert(g: Set[Ref], pre_node: Ref, post_node: Ref)
    returns (new_g: Set[Ref], new_node_1: Ref, new_node_2: Ref)

    requires RING(g)
    requires UNSHARED_CONNECTED(g)
    requires pre_node in g && post_node in g
    requires pre_node.next == post_node
    requires forall n:Ref, m:Ref ::
        { P_(g,n,m) }
        { P_(g,n,pre_node), P_(g,pre_node,m) }
        { P_(g,n,post_node), P_(g,post_node,m) }
            n in g && m in g ==> P_(g,n,m)

    ensures RING(new_g)
    ensures UNSHARED_CONNECTED(new_g)
    ensures !(new_node_1 in g) && !(new_node_2 in g)
    ensures new_g == g union Set(new_node_1, new_node_2)
    ensures pre_node.next == new_node_1 && new_node_1.next == new_node_2 && new_node_2.next == post_node
    ensures forall n:Ref, m:Ref ::
        { P_(new_g,n,m) }
            n in new_g && m in new_g
                ==> P_(new_g,n,m)
{
    var new_g_tmp: Set[Ref]
    new_g_tmp, new_node_1 := create_node(g)
    assume apply_AtomicTCFraming(g, new_node_1)
    // assume apply_DepToTcWisdom(g, Set(new_node_1))

    new_g, new_node_2 := create_node(new_g_tmp)
    assume apply_AtomicTCFraming(new_g_tmp, new_node_2)
    // assume apply_DepToTcWisdom(new_g_tmp, Set(new_node_2))

    
    
    
    
    // new_node_1.next := new_node_2
    // if ( new_node_1.next != null ) {
    //     unlink_ZOPG_next(new_g, new_node_1)
    // }
    link_ZOPG_next(new_g, new_node_1, new_node_2)

    // new_node_2.next := post_node
    // if ( new_node_2.next != null ) {
    //     unlink_ZOPG_next(new_g, new_node_2)
    // }
    link_ZOPG_next(new_g, new_node_2, post_node)

    // Encoding pre_node.next := new_node_1 ...
    if ( pre_node.next != null ) {
        unlink_ZOPG_next(new_g, pre_node)
    }
    link_ZOPG_next(new_g, pre_node, new_node_1)

    assert P_(new_g, pre_node, post_node)

    assert forall n:Ref :: 
        { P_(new_g, pre_node, n) }
            n in new_g ==> P_(new_g, pre_node, n)

    // assert false
}
