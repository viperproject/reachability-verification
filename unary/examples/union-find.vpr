import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/purification.vpr"
import "../_preambles/memspecs.vpr"

import "../../_preambles/common/graph.vpr"
import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

    
define unshared(g)
    unshared_graph($$(g))

define acyclic(g)
    acyclic_graph($$(g))

define E(g, p, s) 
    edge($$(g), p, s)

define P(g, p, s)
    (exists_path($$(g), p, s))

define E0(g, p, s)
    old(E(g, p, s))

define P0(g, p, s)
    old(P(g, p, s))


function interval(g:Set[Ref], a:Ref, b:Ref): Set[Ref]
    requires READONLY_NODES(g)
    requires a in g && b in g
    ensures forall n:Ref :: 
        { n in result } 
            n in g ==> (P(g, a, n) && P(g, n, b) <==> n in result)

// function tailInterval(g:Set[Ref], a:Ref): Set[Ref]
//     requires GRAPH(g)
//     requires a in g && b in g
//     ensures forall n:Ref :: 
//         { n in result } 
//             P(g, a, n) && P(g, n, b) <==> n in result

//TODO
// method lemmaUReachIsIdempotent(g: Set[Ref], x: Ref)
//     requires GRAPH(g)
//     // requires g == inst_uReach($$(g), x)
//     requires x in g

//     ensures GRAPH(g)
// {
//     assert inst_uReach($$(g), x) == inst_uReach($$( inst_uReach($$(g), x) ), x)
// }


method mFind(g: Set[Ref], modif:Set[Ref], x: Ref, 
            root: Ref) // ghost parameter
    
    returns (retval: Ref)
    requires GRAPH(g)
    requires modif subset g
    requires x in modif && root in modif
    requires modif == interval(g, x, root)
    requires forall n:Ref :: { P(g, n, root) } n in g ==> P(g, n, root)

    ensures GRAPH(g)
    ensures retval in g
    ensures forall n:Ref :: { P(g, n, root) } n in g ==> P(g, n, root)
    ensures retval == root
    ensures forall a:Ref, b:Ref :: 
        { P(g, a, b) } 
        { P(g, x, a), P(g, x, b) }
            P(g, x, a) && P(g, x, b) ==> ( P(g, a, b) <==> a == b || b == root )
{
    var i:Ref := x.next; 

    if (i != null) {
        // assume i != null

        assume (interval(g, i, root) subset g)

        i := mFind(g, interval(g, i, root), i, root);
        
        var x1: Ref := x.next

        // Encoding x.next := i;
        unlink_DAG_next(g, x)
        link_DAG_next(g, x, i)

        // Needed semantic assertion
        assert x1 != null ==> P(g, x1, root)
    }
    else {
        i := x; 
    }
    
    // Needed syntactic assertion
    assert __learn_trigger__( P(g, x, root) )
    
    retval := i; 
}

// method mUnion(g: Set[Ref], x: Ref, y: Ref,
//               root_x: Ref, root_y: Ref) // ghost parameter
//     requires GRAPH(g)
//     requires x in g && y in g
//     requires x != null && y != null
//     requires forall n:Ref :: { P(g, n, root_x) } n in g ==> P(g, n, root_x)
//     requires forall n:Ref :: { P(g, n, root_y) } n in g ==> P(g, n, root_y)

//     ensures GRAPH(g)
//     ensures forall a:Ref, b:Ref :: 
//         {}
//             (P(g, x, a) || P(g, y, a)) && 
//             (P(g, x, b) || P(g, y, b)) 
//                 && P0(g, x, a) ==> 
// {
//     var t: Ref
//     t := mFind(g, x, root_x)
//     var s: Ref 
//     assume forall n:Ref :: { P(g, n, root_y) } n in g ==> P(g, n, root_y)
//     s := mFind(g, y, root_y)

//     if ( t != s ) {
//         t.next := s; 
//     }
// }