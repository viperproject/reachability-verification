import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../_preambles/memspecs.vpr"

import "../../_preambles/common/graph.vpr"
import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

import "../../_preambles/macros.vpr"


method lemma_IdempotentIntervals(g: Set[Ref], x:Ref, y:Ref)
    requires GRAPH(g)
    requires x in g && y in g
    requires P(g, x, y)
{
    var s: Set[Ref] := interval(g, x, y)

    assert interval(s, x, y) == s
}

// method lemma_ClosedIntervals(g: Set[Ref], x:Ref, root:Ref)
//     requires GRAPH(g)
//     requires acyclic(g)
//     requires x in g && root in g && root.next == null
//     requires forall n:Ref :: { P(g, n, root) } n in g ==> P(g, n, root)
// {
//     var s: Set[Ref] := rootInterval(g, x, root)

//     assume root.next == null
//     assert __learn_trigger__( P(g, root.next, root) )

//     assert CLOSED(s)
// }

method lemma_NextOfRootIsNull(g: Set[Ref], root:Ref)
    requires GRAPH(g) && root in g
    requires acyclic(g)
    requires forall n:Ref :: { P(g, n, root) } n in g ==> P(g, n, root)
{
    // // CLOSED(g)
    // assert ( forall n:Ref ::
    //     { n.next in g }
    //     { n in g, n.next }
    //         n in g && n.next != null ==> n.next in g )
    // assert root in g && (root.next == null || root.next in g)
    // assert root.next in g ==> P(g, root.next, root)
    // assert !E(g, root.next, root)

    assert __learn_trigger__( P(g, root.next, root) )

    assert root.next == null
}

method lemma_NoPathFromRoot(g: Set[Ref], root:Ref)
    requires GRAPH(g) && root in g
    requires acyclic(g)
    requires forall n:Ref :: { P(g, n, root) } n in g ==> P(g, n, root)
{
    // CLOSED(g)
    // assert ( forall n:Ref ::
    //     { n.next in g }
    //     { n in g, n.next }
    //         n in g && n.next != null ==> n.next in g )
    // assert root in g && (root.next == null || root.next in g)
    // assert root.next in g ==> P(g, root.next, root)
    // assert !E(g, root.next, root)
    // assert root.next == null

    assert forall n:Ref :: { P(g,root,n) } n in g && n != root ==> !P(g, root, n)
}

//TODO
// method lemmaUReachIsIdempotent(g: Set[Ref], x: Ref)
//     requires GRAPH(g)
//     // requires g == inst_uReach($$(g), x)
//     requires x in g

//     ensures GRAPH(g)
// {
//     assert inst_uReach($$(g), x) == inst_uReach($$( inst_uReach($$(g), x) ), x)
// }

method lemma_NoNullOnPath(g:Set[Ref], x:Ref)
    requires x in g
    requires GRAPH(g)
{
    assert forall n:Ref :: { P(g, x, n) } P(g, x, n) ==> n != null
}

method lemma_PathStaysInGraph(g:Set[Ref], x:Ref)
    requires x in g
    requires GRAPH(g)
{
    assert forall n:Ref :: { P(g, x, n) } P(g, x, n) ==> n in g
}

define ROOT(g, r)
    (r in g)
    && (r.next == null)
    && (forall n:Ref :: { P(g, n, r) } n in g           ==> P(g, n, r) )
    // && (forall m:Ref :: { P(g, r, m) } m in g && m != r ==> !P(g, r, m) )

define SOURCE(g, s)
    (s in g)
    && (forall n:Ref :: { P(g, s, n) } n in g ==> P(g, s, n) )
    && (forall m:Ref :: { P(g, m, s) } m in g && m != s ==> !P(g, m, s))

define INTERVAL(graph, a, b)
    !(null in graph)
    && acyclic_graph($$(graph))
    && SOURCE(graph, a)
    && ROOT(graph, b)
    && P(graph, a, b)
    && (forall n:Ref :: 
        { P(graph, a, n) }
        { P(graph, n, b) }
            n in graph ==> P(graph, a, n) && P(graph, n, b))

function interval(g:Set[Ref], a:Ref, b:Ref): Set[Ref]
    requires READONLY_NODES(g) // can be an open graph
    requires !(null in g)
    requires a in g && b in g
    requires P(g, a, b)

    ensures result subset g
    ensures INTERVAL(result, a, b)
    ensures CLOSED(result)
    ensures result == interval(result, a, b)
    ensures a == b ==> result == Set(b)

function subInterval(s:Set[Ref], a:Ref, b:Ref): Set[Ref]
    requires READONLY_NODES(s)
    requires INTERVAL(s, a, b)

    ensures s == result union Set(a)
    ensures !(a in result)
    // ensures result subset s
    ensures a != b ==> result == interval(s, a.next, b)
    ensures a == b ==> result == Set()
    ensures CLOSED(result)
// {
//     a == b ? Set() : interval(s, a.next, b)
// }

method mFind(g: Set[Ref], x: Ref, 
            root: Ref) // ghost parameter
    
    returns (retval: Ref)

    requires GRAPH(g)
    requires SOURCE(g, x) && ROOT(g, root)
    requires g == interval(g, x, root)

    ensures GRAPH(g)
    ensures acyclic(g)
    ensures retval in g 
    ensures ROOT(g, retval)
    ensures retval == root
    ensures (forall m:Ref :: { P(g, m, x) } m in g && m != x ==> !P(g, m, x))
    ensures (forall a:Ref, b:Ref :: 
        { P(g, a, b) } 
        { P(g, x, a), P(g, x, b) }
            a in g && b in g ==> ( P(g, a, b) <==> a == b || b == retval ))
{
    var i:Ref := x.next; 

    if (i != null) {
        // Encoding recursive call ...
        var g1:Set[Ref] := subInterval(g, x, root)
        // assume g1 == interval(g, i, root)
        i := mFind(g1, i, root);
        assume apply_TCFraming(g1, Set(x))

        // Encoding x.next := i; ...
        unlink_DAG_next(g, x)
        link_DAG_next(g, x, i)
    } else {
        i := x; 
    }

    retval := i; 
}