import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/skolems.vpr"

import "../../_preambles/legoFraming.vpr"

import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"

import "../../_preambles/common/graph.vpr"
import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

import "../../_preambles/macros.vpr"

method reverse(g:Set[Ref], xe:Ref) returns (y:Ref)
    requires GRAPH(g)
    requires CLOSED(g)
    requires xe in g

    requires ACYCLIC(g)
    requires UNSHARED(g)
    requires GLOBAL_ROOT(g, xe)

    ensures GRAPH(g) && CLOSED(g)
    ensures UNSHARED(g)
    ensures forall v1:Ref, v2:Ref :: { E0(g,v1,v2) }{ E_(g,v1,v2) } v1 in g && v2 in g && v1 != y ==> ( E0(g,v1,v2) <==> E_(g,v2,v1) )
    ensures forall v1:Ref, v2:Ref :: { E0(g,v1,v2) }{ E_(g,v2,v1) } v1 in g && v2 in g            ==> ( E_(g,v2,v1) ==> E0(g,v1,v2) )
    ensures y != null ==> GLOBAL_ROOT(g, y)
{
    var t:Ref := null
    var x:Ref := xe
    y := null

    while ( x != null )

        // Memory management
        invariant GRAPH(g)
        invariant CLOSED(g)
        invariant x != null ==> x in g
        invariant y != null ==> y in g

        // (5.10)
        invariant forall n:Ref :: {P_(g,x,n)}{P_(g,y,n)} n in g ==> ( P_(g,x,n) ||  P_(g,y,n))
        invariant forall n:Ref :: {P_(g,x,n)}{P_(g,y,n)} n in g ==> (!P_(g,x,n) || !P_(g,y,n))
        invariant ACYCLIC(g)
        invariant UNSHARED(g)

        // The gap
        invariant x != xe && x != null ==> !P_(g,x,xe)
        invariant x != null ==> !E_(g,x,y)

        // (5.12)
        invariant forall v1:Ref, v2:Ref :: {E0(g,v1,v2)}{E_(g,v1,v2)} P_(g,x,v1)            ==> ( E0(g,v1,v2) <==> E_(g,v1,v2) )

        // (5.13)
        invariant forall v1:Ref, v2:Ref :: {E0(g,v1,v2)}{E_(g,v1,v2)} P_(g,y,v2) && v1 != y ==> ( E0(g,v1,v2) <==> E_(g,v2,v1) )

        // (5.14)
        invariant y != null && x != null ==> E0(g,y,x)
    {
        var save_g:Set[Edge] := $$(g)
        var save_y: Ref := y
        var save_x: Ref := x

        t := x.next

        //x.next := y
        unlink_DAG_next(g, x)
        link_DAG_next(g, x, y)

        y := x
        x := t

        //Transformer (5.15)
        assert save_y != null ==> forall v1:Ref, v2:Ref :: { v1 in g, v2 in g }
            v1 in g && v2 in g ==> (
                E_(g,v1,v2) <==> ( edge(save_g,v1,v2) && v1 != save_x ) || ( v1 == save_x && v2 == save_y )
            )
    }
}