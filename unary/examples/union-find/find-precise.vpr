import "../../../_preambles/TrCloDomain.vpr"
import "../../../_preambles/purification.vpr"
import "../../_preambles/convexFraming.vpr"
import "../../../_preambles/memspecs.vpr"
import "../../_preambles/memspecs.vpr"

import "../../../_preambles/common/graph.vpr"
import "../../../_preambles/common/dag.vpr"
import "../../_preambles/dag.vpr"

import "../../../_preambles/macros.vpr"


// method lemma_IdempotentIntervals(g: Set[Ref], x:Ref, y:Ref)
//     requires CLOSED_GRAPH(g)
//     requires x in g && y in g
//     requires P_(g, x, y)
// {
//     var s: Set[Ref] := interval(g, x, y)

//     assert interval(s, x, y) == s
// }

// // method lemma_ClosedIntervals(g: Set[Ref], x:Ref, root:Ref)
// //     requires CLOSED_GRAPH(g)
// //     requires ACYCLIC(g)
// //     requires x in g && root in g && root.next == null
// //     requires forall n:Ref :: { P_(g, n, root) } n in g ==> P_(g, n, root)
// // {
// //     var s: Set[Ref] := rootInterval(g, x, root)

// //     assume root.next == null
// //     assert __learn_trigger__( P_(g, root.next, root) )

// //     assert CLOSED(s)
// // }

// method lemma_NextOfRootIsNull(g: Set[Ref], root:Ref)
//     requires CLOSED_GRAPH(g) && root in g
//     requires ACYCLIC(g)
//     requires forall n:Ref :: { P_(g, n, root) } n in g ==> P_(g, n, root)
// {
//     // // CLOSED(g)
//     // assert ( forall n:Ref ::
//     //     { n.next in g }
//     //     { n in g, n.next }
//     //         n in g && n.next != null ==> n.next in g )
//     // assert root in g && (root.next == null || root.next in g)
//     // assert root.next in g ==> P_(g, root.next, root)
//     // assert !E_(g, root.next, root)

//     assert __learn_trigger__( P_(g, root.next, root) )

//     assert root.next == null
// }

// method lemma_NoPathFromRoot(g: Set[Ref], root:Ref)
//     requires CLOSED_GRAPH(g) && root in g
//     requires ACYCLIC(g)
//     requires forall n:Ref :: { P_(g, n, root) } n in g ==> P_(g, n, root)
// {
//     // CLOSED(g)
//     // assert ( forall n:Ref ::
//     //     { n.next in g }
//     //     { n in g, n.next }
//     //         n in g && n.next != null ==> n.next in g )
//     // assert root in g && (root.next == null || root.next in g)
//     // assert root.next in g ==> P_(g, root.next, root)
//     // assert !E_(g, root.next, root)
//     // assert root.next == null

//     assert forall n:Ref :: { P_(g,root,n) } n in g && n != root ==> !P_(g, root, n)
// }

// //TODO
// // method lemmaUReachIsIdempotent(g: Set[Ref], x: Ref)
// //     requires CLOSED_GRAPH(g)
// //     // requires g == inst_uReach($$(g), x)
// //     requires x in g

// //     ensures CLOSED_GRAPH(g)
// // {
// //     assert inst_uReach($$(g), x) == inst_uReach($$( inst_uReach($$(g), x) ), x)
// // }

// method lemma_NoNullOnPath(g:Set[Ref], x:Ref)
//     requires x in g
//     requires CLOSED_GRAPH(g)
// {
//     assert forall n:Ref :: { P_(g, x, n) } P_(g, x, n) ==> n != null
// }

// method lemma_PathStaysInGraph(g:Set[Ref], x:Ref)
//     requires x in g
//     requires CLOSED_GRAPH(g)
// {
//     assert forall n:Ref :: { P_(g, x, n) } P_(g, x, n) ==> n in g
// }

define TAIL(g, head, tail)
    (head in g)
    && (tail in g)
    && P_(g, head, tail)
    && tail.next == null

define ROOT(g, r)
    (r in g)
    && (r.next == null)
    && (forall n:Ref :: { P_(g, n, r) } n in g           ==> P_(g, n, r) )
    && (forall m:Ref :: { P_(g, r, m) } m in g && m != r ==> !P_(g, r, m) )

define SOURCE_(g, s)
    (s in g)
    && (forall n:Ref :: { P_(g, s, n) } n in g ==> P_(g, s, n) )
    && (forall m:Ref :: { P_(g, m, s) } m in g && m != s ==> !P_(g, m, s))

define INTERVAL(graph, a, b)
    !(null in graph)
    && acyclic_graph($$(graph))
    && SOURCE_(graph, a)
    && ROOT(graph, b)
    && P_(graph, a, b)
    && (forall n:Ref :: 
        { P_(graph, a, n) }
        { P_(graph, n, b) }
            n in graph ==> P_(graph, a, n) && P_(graph, n, b))

function interval(g:Set[Ref], a:Ref, b:Ref): Set[Ref]
    requires READONLY_NODES(g) // can be an open graph
    requires !(null in g)
    requires a in g && b in g
    requires P_(g, a, b)

    ensures result subset g
    ensures INTERVAL(result, a, b)
    ensures forall n:Ref :: 
        { P_(g, a, n) } 
        { P_(result, a, n) }
            n in g && P_(g, a, n) ==> P_(result, a, n)
    ensures CLOSED(result)
    ensures result == interval(result, a, b)
    ensures a == b ==> result == Set(b)

function subInterval(s:Set[Ref], a:Ref, b:Ref): Set[Ref]
    requires READONLY_NODES(s)
    requires INTERVAL(s, a, b)

    ensures s == result union Set(a)
    ensures !(a in result)
    // ensures result subset s
    ensures a != b ==> result == interval(s, a.next, b)
    ensures a == b ==> result == Set()
    ensures CLOSED(result)
// {
//     a == b ? Set() : interval(s, a.next, b)
// }

method mFind(g: Set[Ref], x: Ref, 
            root: Ref) // ghost parameter
    
    returns (retval: Ref)

    requires GRAPH(g) && CLOSED(g)
    requires SOURCE_(g, x) && ROOT(g, root)
    requires g == interval(g, x, root)

    ensures GRAPH(g) && CLOSED(g)
    ensures ACYCLIC(g)
    ensures retval in g 
    ensures ROOT(g, retval)
    ensures retval == root
    ensures (forall m:Ref :: { P_(g, m, x) } m in g && m != x ==> !P_(g, m, x))
    ensures (forall a:Ref, b:Ref :: 
        { P_(g, a, b) } 
        { P_(g, x, a), P_(g, x, b) }
            a in g && b in g ==> ( P_(g, a, b) <==> a == b || b == retval ))
{
    var i:Ref := x.next; 

    if (i != null) {
        // Encoding recursive call ...
        var g1:Set[Ref] := subInterval(g, x, root)
        // assume g1 == interval(g, i, root)
        label l1
        i := mFind(g1, i, root);
        assume apply_ConvexTCFraming(g1, $$(g), old[l1]($$(g)))

        // Encoding x.next := i; ...
        unlink_DAG_next(g, x)
        link_DAG_next(g, x, i)
    } else {
        i := x; 
    }

    retval := i; 
}