import "../../_preambles/common/zopg.vpr"

// Should be applied together with framing
function apply_DepToTcWisdom(g0:Set[Ref], g1:Set[Ref]): Bool
    requires NODES(g0, 1/2)
    requires NODES(g1, 1/2)
    ensures forall u:Ref, v:Ref :: 
        { DEP($$(g0 union g1), u, v, u, u.next) }
        { DEP($$(g0 union g1), u, v.next, v, v.next) } 
            u in g0 && v in g0 ==> __learn_trigger__( exists_path($$(g0 union g1),u,v) )
    ensures forall u:Ref, v:Ref :: 
        { DEP($$(g1 union g0), u, v, u, u.next) }
        { DEP($$(g1 union g0), u, v.next, v, v.next) } 
            u in g1 && v in g1 ==> __learn_trigger__( exists_path($$(g1 union g0),u,v) )
    ensures forall u:Ref, v:Ref :: 
        { DEP($$(g0 union g1), u, v, u, u.next) }
        { DEP($$(g0 union g1), u, v.next, v, v.next) } 
            u in g0 && v in g0 ==> __learn_trigger__( exists_path($$(g0 union g1),u,v) )
    ensures forall u:Ref, v:Ref :: 
        { DEP($$(g1 union g0), u, v, u, u.next) }
        { DEP($$(g1 union g0), u, v.next, v, v.next) } 
            u in g1 && v in g1 ==> __learn_trigger__( exists_path($$(g1 union g0),u,v) )

method unlink_ZOPG_next(g:Set[Ref], node:Ref)
    requires node in g
    requires PROTECTED_GRAPH(g,node)
    ensures PROTECTED_GRAPH(g,node)
    ensures node.next == null
    ensures old(node.next) == null ==> $$(g) == old($$(g))
    ensures old(node.next) != null ==> ZOPG_UNLINK__PRECISE_EDGE_UPDATE_FORMULA(g, node, old(node.next))
    ensures old(node.next) != null ==> ZOPG_UNLINK__PRECISE_TC_UPDATE_FORMULA(g, node, old(node.next))

method link_ZOPG_next(g:Set[Ref], from:Ref, to:Ref)
    requires from in g
    requires to != null ==> to in g
    requires PROTECTED_GRAPH(g,from) && from.next == null
    ensures PROTECTED_GRAPH(g,from)
    ensures from.next == to
    ensures (to == null) ==> $$(g) == old($$(g))
    ensures (to != null) ==> ZOPG_LINK__PRECISE_EDGE_UPDATE_FORMULA(g, from, to)
    ensures (to != null) ==> ZOPG_LINK__PRECISE_TC_UPDATE_FORMULA(g, from, to)      

    // Automatic reasoning support
    // a. Arity-independent
    ensures forall n:Ref, m:Ref :: 
        { exists_path($$(g), n, m) } 
            n in g && m in g ==> 
                __learn_trigger__( exists_path($$(g), n, from) ) && 
                __learn_trigger__( exists_path($$(g), from, m) )
    ensures (to != null) ==> forall n:Ref, m:Ref :: 
        { exists_path($$(g), n, m) } 
            n in g && m in g ==> 
                __learn_trigger__( exists_path($$(g), n, to) ) && 
                __learn_trigger__( exists_path($$(g), to, m) )

    // b. Arity-dependent
    ensures forall n:Ref :: 
        { exists_path($$(g), to, n) }
        { exists_path($$(g), from, n) } 
            n in g && n != from ==> __learn_trigger__(DEP($$(g), from, n, from, from.next))
    ensures (to != null) ==> forall n:Ref :: 
        { exists_path($$(g), to, n) }
        { exists_path($$(g), from, n) } 
            n in g && n != to ==> __learn_trigger__(DEP($$(g), to, n, to, to.next))
    ensures forall n:Ref :: 
        { exists_path($$(g), n, to) }
        { exists_path($$(g), n, from) } 
            n in g && n != from ==> __learn_trigger__(DEP($$(g), n, from, n, n.next))
    ensures (to != null) ==> forall n:Ref :: 
        { exists_path($$(g), n, to) }
        { exists_path($$(g), n, from) } 
            n in g && n != to ==> __learn_trigger__(DEP($$(g), n, to, n, n.next)) // never helped so far

    ensures (to != null) ==> forall n:Ref :: 
        { DEP($$(g), to, n, to, to.next) }
        { DEP($$(g), from, n, from, from.next) } 
            n in g ==> 
                __learn_trigger__( exists_path($$(g), from, n) ) && 
                __learn_trigger__( exists_path(old($$(g)), from, n) ) // never helped so far

    ensures (to != null) ==> forall n:Ref :: 
        { DEP($$(g), to, n, to, to.next) }
        { DEP($$(g), from, n, from, from.next) } 
            n in g ==> 
                __learn_trigger__( exists_path($$(g), to, n) ) && 
                __learn_trigger__( exists_path(old($$(g)), to, n) )

