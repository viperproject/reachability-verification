method unlink_DAG_next(g: Set[Ref], x:Ref)
    requires x in g
    requires PROTECTED_GRAPH(g,x)// && acyclic_graph($$(g))
    ensures PROTECTED_GRAPH(g,x)
    ensures x.next == null
    ensures old(x.next) == null ==> $$(g) == old($$(g))
    ensures old(x.next) != null ==> forall v1:Ref, v2:Ref ::
        { edge($$(g),v1,v2) }
            edge($$(g),v1,v2) <==> edge(old($$(g)),v1,v2) && !(v1==x && v2==old(x.next))
    ensures old(x.next) != null ==> forall v1: Ref, v2: Ref ::
        {exists_path($$(g), v1, v2)}
            !exists_path(old($$(g)), v1, v2)  ==> !exists_path($$(g), v1, v2)
    ensures old(x.next) != null ==> forall v1:Ref, v2:Ref ::
        { exists_path($$(g),v1,v2) }
             exists_path($$(g),v1,v2) <==> (v1==v2) ||
                ( exists n:Ref :: exists_path(old($$(g)),v1,n) && exists_path(old($$(g)),n,v2) &&

                    ( !exists_path(old($$(g)),n,x) && !exists_path(old($$(g)),x,n) ||
                      !exists_path(old($$(g)),n,old(x.next)) && !exists_path(old($$(g)),old(x.next),n) )
                )
                ||
                ( exists n:Ref :: n != x && n != old(x.next) && exists_path(old($$(g)),x,n) && exists_path(old($$(g)),n,old(x.next)) )
                ||
                ( exists u:Ref, v:Ref :: (u != x || v != old(x.next)) && edge(old($$(g)),u,v) && 
                                                                        exists_path(old($$(g)),v1,u) &&
                                                                        exists_path(old($$(g)),u,x) && 
                                                                        exists_path(old($$(g)),old(x.next),v) &&
                                                                        exists_path(old($$(g)),v,v2) )

method link_DAG_next(g:Set[Ref], x:Ref, y:Ref)
    requires x in g
    requires y != null ==> y in g && y != x
    requires PROTECTED_GRAPH(g,x) 
    ensures PROTECTED_GRAPH(g,x)
    ensures x.next == y
    ensures y == null ==> $$(g) == old($$(g))
    ensures y != null ==> forall v1:Ref, v2:Ref ::
        { edge(old($$(g)),v1,v2) }
            edge($$(g),v1,v2) <==> edge(old($$(g)),v1,v2) || (v1==x && v2==y)
    ensures y != null ==> forall v1:Ref, v2:Ref ::
        { exists_path($$(g),v1,v2) }
            exists_path($$(g),v1,v2) <==> exists_path(old($$(g)),v1,v2) || (exists_path(old($$(g)),v1,x) && exists_path(old($$(g)),y,v2))