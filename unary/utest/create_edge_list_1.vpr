import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

method join(g0:Set[Ref], g1:Set[Ref], x0:Ref, x1:Ref) returns (x:Ref, last:Ref)
    requires GRAPH(g0) && CLOSED(g0) 
    requires x0 in g0

    requires GRAPH(g1)  && CLOSED(g1) 
    requires x1 in g1

    requires DISJOINT(g0,g1)

    requires ACYCLIC_LIST_SEGMENT(g0)
    requires ACYCLIC_LIST_SEGMENT(g1)

    requires GLOBAL_ROOT(g0,x0)
    requires GLOBAL_ROOT(g1,x1)


{
    last := x0
    assert last != null
    while ( last.next != null )
        // Preserving the info from the precondition:
        invariant GRAPH(g0) && CLOSED(g0) 
        invariant x0 in g0

        invariant GRAPH(g1) && CLOSED(g1) 
        invariant x1 in g1

        invariant DISJOINT(g0,g1)

        invariant ACYCLIC_LIST_SEGMENT(g0)
        invariant ACYCLIC_LIST_SEGMENT(g1)

        invariant GLOBAL_ROOT(g0,x0)
        invariant GLOBAL_ROOT(g1,x1)

        // Counter variable:
        invariant last in g0

        // The loop does not mutate the graph's edges
        invariant $$(g0) == old($$(g0))
        invariant $$(g1) == old($$(g1))
    {
        last := last.next
    }

    // The NoExit axiom applications can be inlined:
    //assume apply_noExit($$(g0 union g1), g0 union g1, g0)
    //assume apply_noExit($$(g0 union g1), g0 union g1, g1)
    assume forall u:Ref,v:Ref :: { P_(g0 union g1,u,v), u in g0, v in g0 } u in g0 && !(v in g0) ==> 
        !P_(g0 union g1,u,v)
    assume forall u:Ref,v:Ref :: { P_(g0 union g1,u,v), u in g1, v in g1 } u in g1 && !(v in g1) ==> 
        !P_(g0 union g1,u,v)
    assume apply_TCFraming(g0,g1)

    link_DAG_next(g0 union g1,last,x1)
    x := x0

    //Post conditions
    assert GRAPH(g0 union g1)
    assert forall u:Ref :: P_(g0 union g1,x,u) <==> P0(g0,x0,u) || P0(g1,x1,u)
    assert forall u:Ref, v:Ref :: E_(g0 union g1,u,v) <==> E0(g0,u,v) || E0(g1,u,v) || (u==last && v==x1)
    assert ACYCLIC_LIST_SEGMENT(g0 union g1)

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}
