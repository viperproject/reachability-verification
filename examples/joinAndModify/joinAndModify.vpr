import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/skolems.vpr"

import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../../binary/_preambles/memspecs.vpr"

import "../../_preambles/common/graph.vpr"
import "../../_preambles/common/dag.vpr"
import "../../binary/_preambles/dag.vpr"

define __CONVEXITY_CHECKES false

// method disconnectAll(h: Set[Ref])
//     requires GRAPH(h)
//     ensures GRAPH(h)
//     ensures forall x:Ref, y:Ref :: 
//         { P_(h, x, y) }
//             x in h && y in h ==> (P_(h, x, y) <==> x == y)
//     ensures forall x:Ref, y:Ref :: 
//         { E_(h, x, y) }
//             x in h && !(y in h) ==> (E_(h, x, y) <==> E0(h, x, y))

define ACYCLIC_IN(g, h)
    (h subset g) && 
    (forall v1:Ref, v2:Ref :: 
        { E_(g, v1, v2) }
        { P_(g, v2, v1) } 
            v1 in h && v2 in h && E_(g, v1, v2) ==> !P_(g, v2, v1))


define HAMMOCK_IN(g, h, s, t) 
    (h subset g) && 
    CLOSED(h) && 
    ACYCLIC_IN(g, h) && 
    // ACYCLIC(h) && 
    (s != t) && 
    (s in h && t in h) 
    // && 
    // (forall n: Ref :: 
    //     { P_(g, s, n) }
    //     { P_(g, n, t) }
    //         n in h ==> P_(g, s, n) && P_(g, n, t)
            // )

// function dummy000(t:Bool): Bool
// {
//     true
// }

// function dummy111(t:Bool): Bool

// function false1rr(a:Ref, b:Ref): Bool
// {
//     false
// }

// function dummy1rr(a:Ref, b:Ref): Bool

define EXPLORE_ONE_LEVEL_LEFT(g, n) {
    assert n.left != null ==> E_(g, n, n.left)// && P_(g, n, n.left)
}

define EXPLORE_ONE_LEVEL_RIGHT(g, n) {
    assert n.right != null ==> E_(g, n, n.right)// && P_(g, n, n.right)
}

define EXPLORE_ONE_LEVEL(g, n) {
    EXPLORE_ONE_LEVEL_LEFT(g, n)
    EXPLORE_ONE_LEVEL_RIGHT(g, n)
}

method caller(g: Set[Ref], 
              h1: Set[Ref], s1: Ref, t1: Ref,  
              h2: Set[Ref], s2: Ref, t2: Ref)
    
    requires GRAPH(g)
    requires g == h1 union h2 
    requires DISJOINT(h1, h2)
    requires HAMMOCK_IN(g, h1, s1, t1)
    requires HAMMOCK_IN(g, h2, s2, t2)
    requires s1.left == null
    requires t2.right == null

    // ensures GRAPH(g)
    // ensures !P_(g, s2, t2)
    // ensures P_(g, s1, t1)
{
    // needed for triggering

    // if ( CHECK_CONVEXITY_CONDITION(h1, g) ) {
        EnableFocusOnConvexSubHeap(g, h1)
    // } else {
        // EnableFocus(g, h1)
    // }
    // if ( CHECK_CONVEXITY_CONDITION(h2, g) ) {
        EnableFocusOnConvexSubHeap(g, h2)
    // } else {
        // EnableFocus(g, h2)
    // } 

    // assert P_(h1, s1, t1)

    // assert P_(g, s1, t1)
    // assume false

    // assert s1 != null
    // assert  s1.right != s2



    link_DAG_left(g, s1, s2)
    // assert s2 != null ==> P_(g, s1, s2) // added for triggering
    // EXPLORE_ONE_LEVEL_LEFT(g, s1)

    // assert t2 != null
    // assert t2.left != t1

    // assume false
    link_DAG_right(g, t2, t1)
    // assert t1 != null ==> P_(g, t2, t1) // added for triggering
    // EXPLORE_ONE_LEVEL_RIGHT(g, t2)

    label l1


    
    
    
    var frame:Set[Ref] := g setminus h2

    EnableFocusOnFrame(h2, g, frame)
    

    // Peek into the frame
    EXPLORE_ONE_LEVEL(g, s1)
    EXPLORE_ONE_LEVEL(g, s2)
    EXPLORE_ONE_LEVEL(g, t1)
    EXPLORE_ONE_LEVEL(g, t2)
    
    

    // assert false
    

    // disconnectAll(h2)
    label l2

    EnableFocusOnConvexSubHeapDbg(g, h2)
    ApplyConvexTCFraming(l1, l2, h2, g, frame)

    assert !P_(h2, s2, t2)
    
    assert P_(g, s1, t1)

    
}

function getU(x:Ref): Ref
function getV(x:Ref): Ref

method link_DAG_rightDbg(g:Set[Ref], from:Ref, to:Ref)
    requires PROTECTED_GRAPH_right(g,from)
    requires from in g
    requires from.right == null
    requires to != null ==> to in g
    requires from.left != null ==> P_(g, from, from.left) // for triggering
    ensures PROTECTED_GRAPH_right(g,from)
    ensures from.right == to
    ensures (to == null) || (old(from.left) == to) ==> ($$(g) == old($$(g)))
    ensures (to != null) && (old(from.left) != to) ==> LINK__PRECISE_EDGE_UPDATE_FORMULA(g, from, to)
    ensures (to != null) && (old(from.left) != to) ==> DAG_LINK__PRECISE_TC_UPDATE_FORMULA(g, from, to)

method link_DAG_leftDbg(g:Set[Ref], from:Ref, to:Ref)
    requires PROTECTED_GRAPH_left(g,from)
    requires from in g
    requires from.left == null
    requires to != null ==> to in g 
    requires from.right != null ==> P_(g, from, from.right) // for triggering
    ensures PROTECTED_GRAPH_left(g,from)
    ensures from.left == to  
    ensures (to == null) || (old(from.right) == to) ==> ($$(g) == old($$(g)))
    ensures (to != null) && (old(from.right) != to) ==> LINK__PRECISE_EDGE_UPDATE_FORMULA(g, from, to)
    ensures (to != null) && (old(from.right) != to) ==> DAG_LINK__PRECISE_TC_UPDATE_FORMULA(g, from, to)


define EnableFocusOnConvexSubHeapDbg(GLOB, MOD) {

    // Soundness Checks
    assert MOD subset GLOB
    CHECK_CONVEXITY(MOD, GLOB)

    if ( MOD != GLOB ) {

    // // Focus for closed partitions
    assume (forall v001:Ref, v002:Ref :: 
        { P_(GLOB, v001, v002) }
        { P_(MOD, v001, v002) } 
            // TRY THIS: 
            // (v001 in MOD) && !(v002 in GLOB setminus MOD) ==> 
            (v001 in MOD) && (v002 in MOD) ==> 
                (P_(GLOB, v001, v002) <==> P_(MOD, v001, v002)))

    assume (forall v001:Ref, v002:Ref :: 
        { E_(MOD, v001, v002) }
        { E_(GLOB, v001, v002) }
            (v001 in MOD) ==> 
                (E_(GLOB, v001, v002) <==> E_(MOD, v001, v002)))

    // assume (forall u0:Ref, v0:Ref :: 
    //     { P_(GLOB, u0, v0) }
    //         u0 in MOD && !(v0 in MOD) && CLOSED(MOD)
    //             ==> !P_(GLOB, u0, v0))

    } // end if ( MOD != GLOB ) 
}

define EnableFocusOnFrameDbg(MOD, GLOB, FRAME) {
    
    // Soundness Checks
    assert GLOB == MOD union FRAME
    assert DISJOINT(MOD, FRAME)
    CHECK_CONVEXITY(MOD, GLOB)

    assume forall v1:Ref, v2:Ref :: 
        
        { P_(FRAME, v1, v2) } 

            v1 in FRAME && v2 in FRAME && 
            (forall z:Ref :: 
                { P_(GLOB, v1, z) }
                { P_(GLOB, z, v2) } 
                    z in MOD ==> !P_(GLOB, v1, z) || !P_(GLOB, z, v2))
            ==> (P_(GLOB, v1, v2) == P_(FRAME, v1, v2))

}