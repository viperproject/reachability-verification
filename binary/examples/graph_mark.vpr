import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/skolems.vpr"
import "../../_preambles/legoFraming.vpr"
import "../_preambles/memspecs.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"

function get(s: Set[Ref]): Ref
    requires |s| > 0
    ensures result in s

method mark(g:Set[Ref], roots:Set[Ref]) returns (marked:Set[Ref])
    requires |roots| > 0
    requires READONLY_GRAPH(g) && CLOSED(g)
    requires roots subset g
    
    ensures roots subset marked
    ensures marked subset g
    ensures READONLY_GRAPH(g) && CLOSED(g)

    // SP_(g,roots,v) denotes the existence of at least one path from any of the nodes in roots to v. 
    ensures forall v:Ref :: {SP_(g,roots,v)} v in g ==> ( v in marked ==> SP_(g,roots,v) )
    ensures forall v:Ref :: {SP_(g,roots,v)} v in g ==> ( SP_(g,roots,v) ==> v in marked )
{
    var x:Ref := get(roots)
    var pending:Set[Ref] := roots
    marked := Set()

    while ( |pending| > 0 )
        // Taking lefte of permissions.
        invariant READONLY_GRAPH(g) && CLOSED(g)

        // Maintaining the graph.
        invariant x in g
        invariant pending subset g
        invariant marked subset g

        invariant SP_(g,roots,x)
        && ( x.right != null ==> E_(g,x,x.right) && P_(g,x.right,x.right) ==> P_(g,x,x.right) )
        && ( x.left != null ==> E_(g,x,x.left) && P_(g,x.left,x.left) ==> P_(g,x,x.left) )

        invariant
        ( roots == pending ) && 
        // ( forall n:Ref :: {n in pending}{n in roots} n in roots <==> n in pending ) &&                                                                   /// (5.22)
        ( forall n:Ref :: {n in marked} n in g ==> !(n in marked) )                                                                                      /// (5.23)
        ||
        // ( forall n:Ref :: {n in pending}{n in marked} n in roots ==> n in marked || n in pending ) &&                                                    /// (5.24)
        ( roots subset (pending union marked) ) && 
        ( forall n:Ref :: {n in pending} n in g ==> !(n in marked && n in pending) ) &&                                                                  /// (5.25)
        ( forall n:Ref :: {SP_(g,roots,n)} n in (pending union marked) ==> SP_(g,roots,n) ) &&                                                           /// (5.26)
        ( forall n1:Ref, n2:Ref :: {E_(g,n1,n2)} n1 in marked && n2 in g && !(n2 in marked) && !(n2 in pending) ==> !E_(g,n1,n2) )        /// (5.27)
    
        invariant DISJOINT(pending, marked)
    {
        // x <- pop(pending)
        x := get(pending)
        pending := pending setminus Set(x)

        // mark x
        marked := marked union Set(x)

        if ( x.left != null && !(x.left in marked) ) {
            pending := pending union Set(x.left)
        }
        if ( x.right != null && !(x.right in marked) ) {
            pending := pending union Set(x.right)
        }
    }


    // TODO: figure out how to automatically trigger the following formulas: 
    assert (forall n:Ref :: 
        {  n in marked, n.left }
            n in marked && n.left in g && !(n.left in marked) ==> __learn_trigger__( E_(g, n, n.left) ))

    assert (forall n:Ref :: 
        {  n in marked, n.right }
            n in marked && n.right in g && !(n.right in marked) ==> __learn_trigger__( E_(g, n, n.right) ))


    assert RELATIVELY_CLOSED(marked, g setminus marked)
    // assume false

    // assume (forall u0:Ref, v0:Ref :: 
    //     { P_(g, u0, v0) }
    //         u0 in marked && !(v0 in marked) && RELATIVELY_CLOSED(marked, g)
    //             ==> !P_(g, u0, v0))

    // The color axiom. This is one way to dynamically instantiate axioms.
    // Instantiation: NoExit[marked, f]
    // Signature: apply_noExit(EG:Set[Edge], U:Set[Ref], M:Set[Ref]): Bool
    assume apply_noExit($$(g), g, marked)
}
 