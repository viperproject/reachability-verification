// Overlapping Purification: 
//  only the beginning of the edges and paths is in the set; 
//  the ends may or may not be in the set. 
//  This may be useful for framing. 
function $$(nodes0: Set[Ref]): Set[Edge]
    requires READONLY_NODES(nodes0)
    ensures (forall v1: Ref, v2: Ref :: 
        { create_edge(v1, v2) } 
            ((v1 in nodes0) && (CLOSED(nodes0) ==> v2 in nodes0) && HEAP_PARTIAL_ORDER(v1,v2)) <==> (create_edge(v1, v2) in result))
    // TODO: consider moving these formulas somewhere else to optimize performance. 
    ensures CLOSED(nodes0) ==> (forall v1: Ref, v2: Ref :: 
        { (v1 in nodes0),(v2 in nodes0), exists_path(result, v1, v2) }
            (v1 in nodes0) && exists_path(result, v1, v2) ==> (v2 in nodes0))
    ensures (forall v1: Ref, v2: Ref :: 
        { (v1 in nodes0),(v2 in nodes0), exists_path(result, v1, v2) } 
            (v2 in nodes0) && exists_path(result, v1, v2) ==> (v1 in nodes0))
    ensures forall h0:Set[Ref] :: 
        { $$(h0) subset result }
        { h0 subset nodes0 }
            (h0 subset nodes0) ==> $$(h0) subset result

// TODO: Check triggers
define CONVEX(state, local_nodes, global_nodes)
    (local_nodes subset global_nodes) && 
    (forall v1:Ref, v2:Ref, u:Ref :: 
        { P(state, global_nodes, v1, u), P(state, global_nodes, u, v2) } 
        //{ __impossible_to_trigger__(v1, v2, u) }
            v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
                !(P(state, global_nodes, v1, u) && P(state, global_nodes, u, v2)))

// TODO: Check triggers
define CONVEX_(local_nodes, global_nodes)
    (local_nodes subset global_nodes) && 
    (forall v1:Ref, v2:Ref, u:Ref :: 
        { P_(global_nodes, v1, u), P_(global_nodes, u, v2) } 
        //{ __impossible_to_trigger__(v1, v2, u) }
            v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
                !(P_(global_nodes, v1, u) && P_(global_nodes, u, v2)))

function __impossible_to_trigger__(a000:Ref, a001:Ref, a002:Ref): Bool

function __trigger_conv_framing_Entries__(bla_1:Ref, bla_2:Ref): Bool
    ensures true

function __trigger_conv_framing_eXits__(bla_1:Ref, bla_2:Ref): Bool
    ensures true

// TODO: Simplify ApplyConvexTCFraming for CLOSED(MOD) and CLOSED(FRAME) ...
define ApplyConvexTCFraming(s_old, s_new, MOD, GLOB, FRAME) {
    
    // split in pre-state
    assume (forall v1:Ref, v2:Ref :: 
        { P(s_old, GLOB, v1, v2), v1 in (FRAME), v2 in MOD }
           
            v1 in (FRAME) && v2 in MOD &&  
            P(s_old, GLOB, v1, v2) ==> 
                (skolem_alpha1(v1,v2) in MOD) &&
                P(s_old, FRAME, v1, skolem_alpha1(v1,v2)) && 
                P(s_old, MOD, skolem_alpha1(v1,v2), v2))

    // merge in pre-state
    assume (forall v1:Ref, v2:Ref, alpha:Ref :: 
            // this one sometimes does not work for mistireous reasons
            { P(s_old, FRAME, v1, alpha), P(s_old, MOD, alpha, v2) } 
            
            // -- very low performance, but cannot avoid this for now
            { P(s_old, FRAME, v1, alpha), v2 in MOD, alpha in MOD, v1 in FRAME } 
            
            // { P(s_old, FRAME, v1, alpha), P(s_new, GLOB, v1, v2) }
            // { P(s_old, GLOB, v1, v2), P(s_old, MOD, alpha, v2) }
            // { P(s_old, GLOB, v1, v2), P(s_old, FRAME, v1, alpha) }
            // { v1 in FRAME, v2 in MOD, alpha in MOD, P0(GLOB, v1, v2) }
            // { v1 in FRAME, v2 in MOD, alpha in MOD, P_(GLOB, v1, v2) }

                (v1 in FRAME) && 
                (v2 in MOD) && (alpha in MOD) &&
                    P(s_old, FRAME, v1, alpha) && P(s_old, MOD, alpha, v2) ==>
                        P(s_old, GLOB, v1, v2))

    // split in post-state
    // assume (forall v1:Ref, v2:Ref :: 
    //     { P(s_new, GLOB, v1, v2), v1 in FRAME, v2 in MOD }
    //         v1 in FRAME && v2 in MOD &&  
    //         P(s_new, GLOB, v1, v2) ==> 
    //             (skolem_alpha2(v1,v2) in MOD) &&
    //             P(s_old, FRAME, v1, skolem_alpha2(v1,v2)) && 
    //             P(s_new, MOD, skolem_alpha2(v1,v2), v2))

    // merge in post-state
    assume (forall v1:Ref, v2:Ref, alpha:Ref :: 
            { P(s_old, FRAME, v1, alpha), P(s_new, MOD, alpha, v2) }
            // { P(s_old, FRAME, v1, alpha), v2 in MOD, alpha in MOD, v1 in FRAME }
            // { P(s_old, FRAME, v1, alpha), v2 in MOD } -- very low performance
            // { P(s_new, GLOB, v1, v2), P(s_new, MOD, alpha, v2) }
            // { P(s_new, GLOB, v1, v2), P(s_old, FRAME, v1, alpha) }
            // { v1 in FRAME, v2 in MOD, alpha in MOD, P0(GLOB, v1, v2) }
            // { v1 in FRAME, v2 in MOD, alpha in MOD, P_(GLOB, v1, v2) }

                (v1 in FRAME) && 
                (v2 in MOD) && (alpha in MOD) &&
                    P(s_old, FRAME, v1, alpha) && P(s_new, MOD, alpha, v2) ==>
                        P(s_new, GLOB, v1, v2))
    
    // adapt-split
    assume (forall v1:Ref, v2:Ref :: 
            { P(s_new, GLOB, v1, v2) }
                // II. Out-In-1
                (v1 in FRAME) && 
                (v2 in MOD) && P(s_new, GLOB, v1, v2) ==> 
                    (skolem_alpha3(v1,v2) in MOD) &&
                    P(s_old, FRAME, v1, skolem_alpha3(v1,v2)) && 
                    P(s_new, MOD, skolem_alpha3(v1,v2), v2))

    // adapt-merge
    assume (forall v1:Ref, v2:Ref, alpha:Ref :: 
            { P(s_old, FRAME, v1, alpha), P(s_new, MOD, alpha, v2) }
            //{ P(s_old, FRAME, v1, alpha), v2 in MOD, alpha in MOD, v1 in FRAME }
            // { P(s_new, GLOB, v1, v2), P(s_new, MOD, alpha, v2) }
            // { P(s_new, GLOB, v1, v2), P(s_old, FRAME, v1, alpha) }
            // { alpha in MOD, P(s_old, GLOB, v1, v2) }
            { P(s_new, GLOB, v1, v2), alpha in MOD }
                // II. Out-In-2
                (v1 in FRAME) && 
                (v2 in MOD) && (alpha in MOD) &&
                    P(s_old, FRAME, v1, alpha) && P(s_new, MOD, alpha, v2) ==> 
                        P(s_new, GLOB, v1, v2))

    // assume (forall v1:Ref, v2:Ref :: 
    //         { P_(GLOB, v1, v2) }
    //         { P(s_new, GLOB, v1, v2) } 
    //         { P(s_old, GLOB, v1, v2) } 
    //             // III. In-Out
    //             (v1 in MOD) && 
    //             !(v2 in MOD) &&
    //             __trigger_conv_framing_eXits__(v1,v2)
    //                 ==> (
    //                 !(forall beta:Ref :: 
    //                     { P(s_new, MOD, v1, beta) }
    //                     { P(s_old, FRAME, beta, v2) }
    //                         (beta in FRAME) ==> 
    //                             !( P(s_new, MOD, v1, beta) && P(s_old, FRAME, beta, v2) ))
    //                 <==> P(s_new, GLOB, v1, v2)
    //             )) 
    // assume (forall v1:Ref, v2:Ref :: 
    //         { P_(GLOB, v1, v2) }
    //         { P(s_new, GLOB, v1, v2) } 
    //         { P(s_old, GLOB, v1, v2) } 
    //             // IV. Out-Out
    //             (v1 in FRAME) && 
    //             !(v2 in MOD) &&
    //             __trigger_conv_framing_Entries__(v1,v2) &&
    //             __trigger_conv_framing_eXits__(v1,v2)
    //             ==> (
    //                 P(s_old, FRAME, v1, v2) || 
    //                 !(forall alpha:Ref, beta:Ref :: 
    //                     { P(s_new, MOD, alpha, beta) }
    //                     { P(s_old, FRAME, v1, alpha), P(s_old, FRAME, beta, v2) } 
    //                         (alpha in MOD) && (beta in FRAME) ==> 
    //                             !( P(s_old, FRAME, v1, alpha) && P(s_new, MOD, alpha, beta) && P(s_old, FRAME, beta, v2) ))
    //                 <==> P(s_new, GLOB, v1, v2)
    //             ))
}

// To be applied before a method call. 
define PartitionPathsInConvexSubHeap(GLOB, MOD) {
    //if ( !__CONVEXITY_CHECKES || CLOSED(MOD) || CLOSED(FRAME) || CONVEX_(MOD, GLOB) ) {

        // (a) In-In:  P(g, _, _) <~~~> P(mod, _, _)
        assume (forall v1:Ref, v2:Ref :: 
            { P_(GLOB, v1, v2) }
            { P_(MOD, v1, v2) } 
                (v1 in MOD) && (v2 in MOD) ==> 
                    (P_(GLOB, v1, v2) <==> P_(MOD, v1, v2)))

        // // (b) In-Out:   P(g, _, _) ~~~> P(mod, _, _)
        // assume (forall v1:Ref, u:Ref, v2:Ref :: 
        //     { P_(GLOB, v1, u), E_(GLOB, u, v2) }
        //     { P_(GLOB, v1, u), P_(MOD, v1, v2) }
        //     { E_(GLOB, u, v2), P_(MOD, v1, v2) }
        //     { P_(GLOB, v1, v2), E_(GLOB, u, v2) }
        //         (v1 in MOD) && 
        //         (u in MOD) &&
        //         !(v2 in MOD) && (v2 in GLOB) ==> 
        //             (P_(GLOB, v1, u) && E_(GLOB, u, v2) ==> P_(MOD, v1, v2)))

        // (c) In-Out:   P(g, _, _) <~~~ P(mod, _, _)
        assume (forall v1:Ref, v2:Ref :: 
            { P_(MOD, v1, v2) }
            { P_(GLOB, v1, v2) }
                (v1 in MOD) && 
                !(v2 in MOD) && (v2 in GLOB) ==> 
                    (P_(MOD, v1, v2) ==> P_(GLOB, v1, v2)))

        // (d1) Out-*:   !P(mod, _, _)
        assume (forall v1:Ref, v2:Ref :: 
            { P_(MOD, v1, v2) }
            { P_(GLOB, v1, v2) }
                !(v1 in MOD) && (v1 in GLOB) && v1 != v2 ==> 
                    (!P_(MOD, v1, v2)))

        // // (d2) Out-In:  P(g, _, _) ~~~> P(frame, _, alpha) P(mod, alpha, _) 
        // assume forall v1:Ref, v2:Ref :: 
        //     { P_(GLOB, v1, v2) }
        //         v1 in (FRAME) && v2 in MOD &&  
        //         P_(GLOB, v1, v2) ==> 
        //             (skolem_alpha(v1,v2) in MOD) &&
        //             P_(FRAME, v1, skolem_alpha(v1,v2)) && 
        //             P_(MOD, skolem_alpha(v1,v2), v2)

        // (e) Partitioning of the egdes
        assume (forall v1:Ref, v2:Ref :: 
            { E_(MOD, v1, v2) }
            { E_(GLOB, v1, v2) }
                (v1 in MOD) ==> 
                    (E_(GLOB, v1, v2) <==> E_(MOD, v1, v2)))

        // (f) NoExit[GLOB, MOD]
        assume (forall u0:Ref, v0:Ref :: 
            // { u0 in g1, v0 in frame }
            { P_(MOD, u0, v0) }
            { P_(GLOB, u0, v0) }
                u0 in MOD && !(v0 in MOD) && CLOSED(MOD)
                    ==> !P_(GLOB, u0, v0))
    //}
}

define EnableFocusOnConvexSubHeap(GLOB, MOD) {
    assume (forall v1:Ref, v2:Ref :: 
        { P_(GLOB, v1, v2) }
        // { P_(MOD, v1, v2) } 
            (v1 in MOD) && (v2 in MOD) ==> 
                (P_(GLOB, v1, v2) <==> P_(MOD, v1, v2)))

    assume (forall v1:Ref, v2:Ref :: 
            { E_(MOD, v1, v2) }
            { E_(GLOB, v1, v2) }
                (v1 in MOD) ==> 
                    (E_(GLOB, v1, v2) <==> E_(MOD, v1, v2)))

    assume (forall u0:Ref, v0:Ref :: 
        { P_(GLOB, u0, v0) }
            u0 in MOD && !(v0 in MOD) && CLOSED(MOD)
                ==> !P_(GLOB, u0, v0))
}

define ApplyNoExitWisdom(GLOB, MOD) {
    assume (forall u0:Ref, v0:Ref :: 
        { P_(GLOB, u0, v0) }
            u0 in MOD && !(v0 in MOD) && CLOSED(MOD)
                ==> !P_(GLOB, u0, v0))
}

/** Intended way of using these formulas: 

    @mod g
    {
label l1
        // { Assumptions about P1(g, _, _) }

        __Split_P__(g1, g)

        call m1()
            @mod g1
            ensures // { P2(g1, _, _) <==> ... }

label l2
        assume ConvexTCFraming(l1, l2, g1, g)
        
        // { Assertions about P2(g, _, _) }
    }
 */