// Overlapping Purification: 
//  only the beginning of the edges and paths is in the set; 
//  the ends may or may not be in the set. 
//  This may be useful for framing. 
function $$(nodes0: Set[Ref]): Set[Edge]
    requires READONLY_NODES(nodes0)
    ensures (forall v1: Ref, v2: Ref :: 
        { create_edge(v1, v2) } 
            ((v1 in nodes0) && (CLOSED(nodes0) ==> (v2 in nodes0)) && HEAP_PARTIAL_ORDER(v1,v2)) <==> (create_edge(v1, v2) in result))
    // TODO: consider moving these formulas somewhere else to optimize performance. 
    ensures CLOSED(nodes0) ==> (forall v1: Ref, v2: Ref :: 
        { (v1 in nodes0),(v2 in nodes0), exists_path(result, v1, v2) }
            (v1 in nodes0) && exists_path(result, v1, v2) ==> (v2 in nodes0))
    ensures (forall v1: Ref, v2: Ref :: 
        { (v1 in nodes0),(v2 in nodes0), exists_path(result, v1, v2) } 
        // { exists_path(result, v1, v2) }
            (v2 in nodes0) && exists_path(result, v1, v2) ==> (v1 in nodes0))
    ensures forall h0:Set[Ref] :: 
        { $$(h0) subset result }
        { h0 subset nodes0 }
            (h0 subset nodes0) ==> $$(h0) subset result
    // ensures (forall larger_EG: Set[Edge] :: 
    //     { result subset larger_EG }
    //         (result subset larger_EG) ==> forall v1:Ref, v2:Ref :: 
    //             { exists_path(result, v1, v2), exists_path(larger_EG, v1, v2) } 
    //                 exists_path(result, v1, v2) ==> exists_path(larger_EG, v1, v2))
    ensures (forall smaller_EG: Set[Edge] :: 
        { smaller_EG subset result }
        // { __register_frame__(smaller_EG, result) }
            (smaller_EG subset result) ==> forall v1:Ref, v2:Ref :: 
                { exists_path(smaller_EG, v1, v2), exists_path(result, v1, v2) } 
                    exists_path(smaller_EG, v1, v2) ==> exists_path(result, v1, v2))
    // ensures forall n0:Ref :: 
    //     // { n0 in nodes0, subheap subset nodes0, n0.left }
    //         {__trigger_path(n0)}
    //         // false && 
    //          n0 in nodes0 && n0.left != null ==> edge(result, n0, n0.left)

// TODO: Check triggers
define CONVEX(state, local_nodes, global_nodes)
    (local_nodes subset global_nodes) && 
    (forall v1:Ref, v2:Ref, u:Ref :: 
        { P(state, global_nodes, v1, u), P(state, global_nodes, u, v2) } 
        //{ __impossible_to_trigger__(v1, v2, u) }
            v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
                !(P(state, global_nodes, v1, u) && P(state, global_nodes, u, v2)))

// TODO: Check triggers
define CONVEX_(local_nodes, global_nodes)
    (local_nodes subset global_nodes) && 
    (forall v1:Ref, v2:Ref, u:Ref :: 
        { P_(global_nodes, v1, u), P_(global_nodes, u, v2) } 
        //{ __impossible_to_trigger__(v1, v2, u) }
            v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
                !(P_(global_nodes, v1, u) && P_(global_nodes, u, v2)))

define CHECK_CONVEXITY(local_nodes, global_nodes) {
    // while (__CONVEXITY_CHECKES )
    //     invariant NODES(global_nodes, 1/2)
    //     invariant local_nodes subset global_nodes
    // {
    //     var q045:Ref 
    //     var p045:Ref
    //     var o045:Ref
    //     assume q045 in local_nodes && p045 in local_nodes && o045 in (global_nodes setminus local_nodes)
    //     assert P_(global_nodes, q045, o045) ==> !P_(global_nodes, o045, p045) 
    // }

    if (__CONVEXITY_CHECKES) { assert 
        CLOSED(local_nodes) || 
        CLOSED(global_nodes setminus local_nodes) || 
        CLOSED_IN(local_nodes, global_nodes) || 
        CONVEX_(local_nodes, global_nodes)
    }
}

function __impossible_to_trigger__(a000:Ref, a001:Ref, a002:Ref): Bool

function __register_frame__(f003:Set[Edge], ctx003:Set[Edge]): Bool

function __trigger_conv_framing_Entries__(bla_1:Ref, bla_2:Ref, bla_3:Ref): Bool
    ensures true

function __trigger_conv_framing_eXits__(bla_1:Ref, bla_2:Ref, bla_3:Ref): Bool
    ensures true

function dummy(v1:Ref, v2:Ref): Bool

function sub(t: Set[Ref], sub_root: Ref): Set[Ref]
    requires GRAPH(t)
    requires sub_root in t    
    ensures result subset t
    ensures CLOSED_IN(result, t)
    ensures !(null in result)
    ensures sub_root in result
    ensures GLOBAL_ROOT(result, sub_root)
    ensures forall n:Ref :: 
        { n in result, P_(t, sub_root, n) }
            n in result ==> P_(t, sub_root, n)
    ensures forall n:Ref :: 
        { P_(t, sub_root, n) }
            P_(t, sub_root, n) ==> n in result 

define EnableFocusOnConvexSubHeap(GLOB, MOD) {
    // Focus for closed partitions
    assume (forall v1:Ref, v2:Ref :: 
        { P_(GLOB, v1, v2) }
        { P_(MOD, v1, v2) } 
            (v1 in MOD) && (v2 in MOD) ==> 
                (P_(GLOB, v1, v2) <==> P_(MOD, v1, v2)))

    // // Focus for uncloded partitions
    // assume (forall v1:Ref, v2:Ref :: 
    //     { P_(MOD, v1, v2) }
    //         (v1 in MOD) && P_(MOD, v1, v2) ==> P_(GLOB, v1, v2))

    // assume (forall v1:Ref, v2:Ref :: 
    //     { P_(GLOB, v1, v2) }
    //         (v1 in MOD) && (v2 in MOD) && 
    //         P_(GLOB, v1, v2) ==> P_(MOD, v1, v2))

    assume (forall v1:Ref, v2:Ref :: 
        { E_(MOD, v1, v2) }
        { E_(GLOB, v1, v2) }
            (v1 in MOD) ==> 
                (E_(GLOB, v1, v2) <==> E_(MOD, v1, v2)))

    assume (forall u0:Ref, v0:Ref :: 
        { P_(GLOB, u0, v0) }
            u0 in MOD && !(v0 in MOD) && CLOSED(MOD)
                ==> !P_(GLOB, u0, v0))
}

define EnableFocus(GLOB, FRAME) {
    assume (forall v1:Ref, v2:Ref :: 
        // { P_(GLOB, v1, v2) }
        { P_(FRAME, v1, v2) } 
            (v1 in FRAME) && (v2 in FRAME) && P_(FRAME, v1, v2) ==> P_(GLOB, v1, v2))

    // assume (forall v1:Ref, v2:Ref :: 
    //     {  }
    //         (v1 in FRAME) && !(v2 in FRAME))

    assume __register_frame__($$(FRAME), $$(GLOB))

    assume (forall v1:Ref, v2:Ref :: 
        { E_(FRAME, v1, v2) }
        { E_(GLOB, v1, v2) }
            (v1 in FRAME) ==> 
                (E_(GLOB, v1, v2) <==> E_(FRAME, v1, v2)))

    assume (forall u0:Ref, v0:Ref :: 
        { P_(GLOB, u0, v0) }
            u0 in FRAME && !(v0 in FRAME) && CLOSED(FRAME)
                ==> !P_(GLOB, u0, v0))
}

// TODO: Simplify ApplyConvexTCFraming for CLOSED(MOD) and CLOSED(FRAME) ...
define ApplyConvexTCFraming(s_old, s_new, MOD, GLOB, FRAME) {

    // -------- O. Frame=const --------

    assume old[s_old]( $$(FRAME) ) == old[s_new]( $$(FRAME) )

    // ----------------------------- // ----------------------------- // -----------------------------
    // -------- II. Out-In --------- // ----------------------------- // -----------------------------
    // ----------------------------- // ----------------------------- // -----------------------------

    // Out-In-split in pre-state
    assume (forall v1:Ref, v2:Ref :: 

        { P(s_old, GLOB, v1, v2) }
           
            v1 in FRAME && /*v2 in MOD &&*/ !(v2 in FRAME) && 
            P(s_old, GLOB, v1, v2) ==> 
                (skolem_alpha1(v1,v2) in MOD) &&
                P(s_old, FRAME, v1, skolem_alpha1(v1,v2)) && 
                P(s_old, MOD, skolem_alpha1(v1,v2), v2))

    // Out-In-merge in pre-state
    assume (forall v1:Ref, v2:Ref, alpha:Ref :: 

            { P(s_old, FRAME, v1, alpha), P(s_old, MOD, alpha, v2) } 

                (v1 in FRAME) && /*(v2 in MOD) &&*/ !(v2 in FRAME) && 
                (alpha in MOD) &&
                    P(s_old, FRAME, v1, alpha) && P(s_old, MOD, alpha, v2) ==>
                        P(s_old, GLOB, v1, v2))

    // Out-In-frame-split 
    assume (forall v1:Ref, v2:Ref :: 
            
            { P(s_new, GLOB, v1, v2) }

                (v1 in FRAME) && /*(v2 in MOD) &&*/ !(v2 in FRAME) && 
                P(s_new, GLOB, v1, v2) ==> 
                    (skolem_alpha3(v1,v2) in MOD) &&
                    P(s_old, FRAME, v1, skolem_alpha3(v1,v2)) && 
                    P(s_new, MOD, skolem_alpha3(v1,v2), v2))

    // Out-In-frame-merge
    assume (forall v1:Ref, v2:Ref, alpha:Ref :: 

            { P(s_old, FRAME, v1, alpha), P(s_new, MOD, alpha, v2) }

                (v1 in FRAME) && /*(v2 in MOD) &&*/ !(v2 in FRAME) && 
                (alpha in MOD) &&
                    P(s_old, FRAME, v1, alpha) && P(s_new, MOD, alpha, v2) ==> 
                        P(s_new, GLOB, v1, v2))


    // ----------------------------- // ----------------------------- // -----------------------------
    // -------- III. In-Out -------- // ----------------------------- // -----------------------------
    // ----------------------------- // ----------------------------- // -----------------------------

    // In-Out-split in pre-state
    assume (forall v1:Ref, v2:Ref :: 

        { P(s_old, GLOB, v1, v2) }
           
            v1 in MOD && /*v2 in FRAME &&*/ !(v2 in MOD) && 
            P(s_old, GLOB, v1, v2) ==> 
                (skolem_beta10(v1,v2) in MOD) &&
                P(s_old, MOD, v1, skolem_beta10(v1,v2)) && 
                P(s_old, FRAME, skolem_beta10(v1,v2), v2))

    // In-Out-merge in pre-state
    assume (forall v1:Ref, v2:Ref, beta:Ref :: 

            { P(s_old, MOD, v1, beta), P(s_old, FRAME, beta, v2) } 

                (v1 in MOD) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                (beta in FRAME) &&
                    P(s_old, MOD, v1, beta) && P(s_old, FRAME, beta, v2) ==>
                        P(s_old, GLOB, v1, v2))

    // In-Out-frame-split 
    assume (forall v1:Ref, v2:Ref :: 

        { P(s_new, GLOB, v1, v2) }
           
            v1 in MOD && /*v2 in FRAME &&*/ !(v2 in MOD) && 
            P(s_new, GLOB, v1, v2) ==> 
                (skolem_beta10(v1,v2) in MOD) &&
                P(s_new, MOD, v1, skolem_beta10(v1,v2)) && 
                P(s_old, FRAME, skolem_beta10(v1,v2), v2))

    // In-Out-frame-merge 
    assume (forall v1:Ref, v2:Ref, beta:Ref :: 

            { P(s_new, MOD, v1, beta), P(s_old, FRAME, beta, v2) } 

                (v1 in MOD) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                (beta in FRAME) &&
                    P(s_new, MOD, v1, beta) && P(s_old, FRAME, beta, v2) ==>
                        P(s_new, GLOB, v1, v2))


    // ----------------------------- // ----------------------------- // -----------------------------
    // -------- IV. Out-Out -------- // ----------------------------- // ----------------------------- 
    // ----------------------------- // ----------------------------- // -----------------------------

    // Out-Out-split in pre-state 
    assume (forall v1:Ref, v2:Ref :: 

        { P(s_old, GLOB, v1, v2) }

                (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                P(s_old, GLOB, v1, v2) ==> 
                    P(s_old, FRAME, v1, v2) || 
                    ((skolem_alpha11(v1,v2) in MOD) && 
                     (skolem_beta11(v1,v2) in FRAME) && 
                     P(s_old, FRAME, v1, skolem_alpha11(v1,v2)) && P(s_old, MOD, skolem_alpha11(v1,v2), skolem_beta11(v1,v2)) && P(s_old, FRAME, skolem_beta11(v1,v2), v2)))
                    

    // Out-Out-merge-1 in pre-state
    assume (forall v1:Ref, v2:Ref, alpha:Ref, beta:Ref :: 
        
        { P(s_old, FRAME, v1, alpha), P(s_old, MOD, alpha, beta), P(s_old, FRAME, beta, v2) }

                (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                (alpha in MOD) && (beta in FRAME) &&
                P(s_old, FRAME, v1, alpha) && P(s_old, MOD, alpha, beta) && P(s_old, FRAME, beta, v2) ==> 
                    P(s_old, GLOB, v1, v2))

    // // Out-Out-merge-2 in pre-state
    // assume (forall v1:Ref, v2:Ref :: 
        
    //     { P(s_old, FRAME, v1, v2) }

    //             (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
    //             P(s_old, FRAME, v1, v2) ==> 
    //                 P(s_old, GLOB, v1, v2))

    // Out-Out-frame-split 
    assume (forall v1:Ref, v2:Ref :: 

        { P(s_new, GLOB, v1, v2) }

                (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                P(s_new, GLOB, v1, v2) ==> 
                    P(s_old, FRAME, v1, v2) || 
                    ((skolem_alpha12(v1,v2) in MOD) && 
                     (skolem_beta12(v1,v2) in FRAME) && 
                     P(s_old, FRAME, v1, skolem_alpha12(v1,v2)) && P(s_new, MOD, skolem_alpha12(v1,v2), skolem_beta12(v1,v2)) && P(s_old, FRAME, skolem_beta12(v1,v2), v2)))
                    
    // Out-Out-frame-merge-1  
    assume (forall v1:Ref, v2:Ref, alpha:Ref, beta:Ref :: 
        
        { P(s_old, FRAME, v1, alpha), P(s_new, MOD, alpha, beta), P(s_old, FRAME, beta, v2) }

                (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
                (alpha in MOD) && (beta in FRAME) &&
                P(s_old, FRAME, v1, alpha) && P(s_new, MOD, alpha, beta) && P(s_old, FRAME, beta, v2) ==> 
                    P(s_new, GLOB, v1, v2))
                
    // // Out-Out-frame-merge-2 
    // assume (forall v1:Ref, v2:Ref :: 
        
    //     { P(s_old, FRAME, v1, v2) }

    //             (v1 in FRAME) && /*(v2 in FRAME) &&*/ !(v2 in MOD) && 
    //             P(s_old, FRAME, v1, v2) ==> 
    //                 P(s_new, GLOB, v1, v2))

}

/** Intended way of using these formulas: 

    @mod g
    {
label l1
        // { Assumptions about P1(g, _, _) }

        __Split_P__(g1, g)

        call m1()
            @mod g1
            ensures // { P2(g1, _, _) <==> ... }

label l2
        assume ConvexTCFraming(l1, l2, g1, g)
        
        // { Assertions about P2(g, _, _) }
    }
 */

define DeduceRelationshipBetweenSubHeaps(SUBHEAP001, HEAP001) {
    assert SUBHEAP001 subset HEAP001
    if ( CLOSED(HEAP001) && CLOSED_IN(HEAP001, SUBHEAP001) ) { 
        assume CLOSED(SUBHEAP001)
    }
}
