import "../../_preambles/TrCloDomain.vpr"

import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


// import "../../_preambles/common/graph.vpr"

// import "../../_preambles/common/dag.vpr"
// import "../_preambles/dag.vpr"

define __CONVEXITY_CHECKES false 

define TREE(t) 
    GRAPH(t) && TREE_IMPL(t)

define TREE_IMPL(t)
    CLOSED(t) && ACYCLIC(t) //&& UNSHARED(t)

function subTree(t: Set[Ref], sub_root: Ref): Set[Ref]
    requires TREE(t)
    requires sub_root in t
    
    ensures result subset t
    ensures TREE_IMPL(result)
    ensures !(null in result)
    ensures sub_root in result
    ensures GLOBAL_ROOT(result, sub_root)
    // ensures result == subTree(result, sub_root)


method mergeRight(tree: Set[Ref], root: Ref, 
                 sub_tree:Set[Ref], root_s: Ref) 
                returns (new_tree: Set[Ref], 
                         link: Ref) // ghost
    
    requires DISJOINT(tree, sub_tree)

    requires TREE(tree)
    requires root in tree
    requires GLOBAL_ROOT(tree, root)

    requires TREE(sub_tree)
    requires root_s in sub_tree
    requires GLOBAL_ROOT(sub_tree, root_s)

    ensures new_tree == tree union sub_tree
    ensures TREE(new_tree)
    ensures CONST_EDGES(sub_tree)

    ensures link in tree 
    ensures link.right == root_s
    ensures forall x:Ref, y:Ref :: 
        { E_(new_tree, x, y) }
        { E0(tree, x, y) }
        { E0(sub_tree, x, y) }
            E_(new_tree, x, y) <==> E0(tree, x, y) || E0(sub_tree, x, y) || 
                                    (x == link && y == root_s) 

    ensures old(root.right) == null ==> root == link && root.right == root_s
    // ensures GLOBAL_ROOT(new_tree, root)
    // ensures forall n:Ref :: 
    //     { P_(new_tree, root, n) }
    //     { P0(sub_tree, root_s, n) }
    //     { P0(tree, root, n) }
    //         P_(new_tree, root, n) <==> P0(tree, root, n) || P0(sub_tree, root_s, n)

    // ensures forall x:Ref, y:Ref :: 
    //     { P_(new_tree, x, y) }
    //     { P0(new_tree, x, y) }
    //     { P0(new_tree, x, link), P0(new_tree, root_s, y) }
    //         (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
    //         (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(new_tree, x, y))) &&
    //         (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(new_tree, x, y))) &&
    //         (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(new_tree, x, link) && P0(new_tree, root_s, y)))

    ensures P_(new_tree, link, root_s)
    ensures forall x:Ref, y:Ref :: 
            { P_(new_tree, x, y) }
            { P0(tree, x, link), P0(sub_tree, root_s, y) }
            { P0(tree, x, y) }
            { P0(sub_tree, x, y) }
                (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
                (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) &&
                (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) &&
                (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(tree, x, link) && P0(sub_tree, root_s, y) || x==link && y==root_s))
{
    new_tree := tree union sub_tree

    PartitionPathsInConvexSubHeap(new_tree, tree)

    if ( root.right != null ) {
        // assume false
        
        var ch_node: Ref := root.right
        var ch_tree: Set[Ref] := subTree(tree, ch_node)
        var frame: Set[Ref] := tree setminus ch_tree

        PartitionPathsInConvexSubHeap(tree, ch_tree)
        PartitionPathsInConvexSubHeap(tree, frame)
        
        var new_ch_tree: Set[Ref]
label l1
        new_ch_tree, link := mergeRight(ch_tree, ch_node, sub_tree, root_s)
label l2

        new_tree := frame union new_ch_tree

        PartitionPathsInConvexSubHeap(new_tree, new_ch_tree)
        PartitionPathsInConvexSubHeap(new_tree, frame)
        // PartitionPathsInConvexSubHeap(new_tree, sub_tree)

        ApplyConvexTCFraming(l1, l2, new_ch_tree, new_tree)
        assume DISJOINT(frame, new_ch_tree)
        
        // assert forall x:Ref, y:Ref :: 
        //     { P0(tree, x, y) }
        //     { P_(new_tree, x, y) }
        //         x in frame && y in ch_tree && P0(tree, x, y) ==> P_(new_tree, x, y)
        
        
        // // Rewritten Proof Goal
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, link), P0(sub_tree, root_s, y) }
        //         x in frame && y in sub_tree && 
        //         P0(tree, x, link) && P0(sub_tree, root_s, y) && P_(new_tree, link, root_s) ==> P_(new_tree, x, y)


        // Proof Goal A
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, link), P0(sub_tree, root_s, y) }
        //         x in frame && y in sub_tree && 
        //         P0(tree, x, link) && P0(sub_tree, root_s, y) ==> P_(new_tree, x, y)

        // // Proof Goal B
        // assert forall x:Ref, y:Ref :: 
        //     { P0(tree, x, y) }
        //     { P_(new_tree, x, y) }
        //         x in frame && y in ch_tree && P0(tree, x, y) ==> P_(new_tree, x, y)




        assert forall x:Ref, y:Ref :: 
            { P_(new_tree, x, y) }
            { P0(tree, x, link), P0(sub_tree, root_s, y) }
            { P0(tree, x, y) }
            { P0(sub_tree, x, y) }
                (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
                (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) &&
                (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) //&&
                // (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(tree, x, link) && P0(sub_tree, root_s, y) || x==link && y==root_s))

        assume false

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, link), P0(sub_tree, root_s, y) }
        //     { P0(tree, x, y) }
        //     { P0(sub_tree, x, y) }
        //         //(x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) && // should be okay
        //         //(x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) && // should be okay
                
        //         // Split A: 
        //         //(x in tree    && y in tree   ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) &&
        //         // (x in ch_tree && y in ch_tree   ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) && // should be okay
        //         // (x in frame   && y in frame     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) && // should be okay
        //         // (x in ch_tree && y in frame     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) && // should be okay
        //         // (x in frame   && y in ch_tree   ==> (P_(new_tree, x, y) <==> P0(tree, x, y)))  && // should be okay
        //         // (x in frame   && y in ch_tree   ==> (P0(tree, x, y) ==> P_(new_tree, x, y)))//&& // the hard case
                
        //         // Split B: 
        //         //  (x in tree   && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(tree, x, link) && P_(new_tree, link, root_s) && P0(sub_tree, root_s, y))) 
        //         (x in ch_tree   && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(tree, x, link) && P0(sub_tree, root_s, y))) //&& // should be okay
        //         (x in frame     && y in sub_tree ==> (P_(new_tree, x, y)  ==> P0(tree, x, link) && P0(sub_tree, root_s, y))) && // should be okay
        //         // (x in frame     && y in sub_tree ==> (P0(tree, x, link) && P0(sub_tree, root_s, y) ==> P_(new_tree, x, y)))  // the hard case - 2
        
        // assume false
        // assume false



    } else {
        assume false
        // PartitionPathsInConvexSubHeap(new_tree, tree)
        // PartitionPathsInConvexSubHeap(new_tree, sub_tree)

        // // Encoding root.right := root_s ...
        // link_DAG_right(new_tree, root, root_s)

        // // Ghost code for writing the postcondition
        // link := root

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, y) }
        //          x in tree && y in tree ==> 
        //             (P_(new_tree, x, y) <==> P0(tree, x, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(sub_tree, x, y) }
        //          x in sub_tree && y in sub_tree ==> 
        //             (P_(new_tree, x, y) <==> P0(sub_tree, x, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //          x in sub_tree && y in tree ==> 
        //             !P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P_(new_tree, x, y) }
        //         (P_(new_tree, x, y) <==> 
        //             P0(new_tree, x, y) || 
        //             P0(new_tree, x, root) && P0(new_tree, root_s, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P0(new_tree, x, root) && P0(new_tree, y, root_s) ==> P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P0(tree, x, root) && P0(sub_tree, y, root_s) ==> P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P_(new_tree, x, y) ==>
        //             P0(tree, x, root) //&& P0(sub_tree, y, root_s) 
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(new_tree, x, root), P0(new_tree, root_s, y) }
        //          x in tree && y in sub_tree ==>
        //             (P_(new_tree, x, y) == P0(new_tree, x, root) && P0(new_tree, root_s, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(new_tree, x, root), P0(sub_tree, root_s, y) }
        //          x in tree && y in sub_tree && P_(new_tree, x, y) ==> P0(sub_tree, root_s, y)


        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree ==> 
        //             (P_(new_tree, x, y) <==> P0(new_tree, x, root) && P0(new_tree, root_s, y))

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(sub_tree, y, root_s) }
        //          x in tree && y in sub_tree ==> 
        //             (P_(new_tree, x, y) <==> P0(tree, x, root) && P0(sub_tree, root_s, y))

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(sub_tree, root_s, y) }
        //     { P0(tree, x, y) }
        //     { P0(sub_tree, x, y) }
        //         (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
        //         (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) &&
        //         (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) &&
        //         (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(tree, x, root) && P0(sub_tree, root_s, y)))
        
        // assume false
    }
}
