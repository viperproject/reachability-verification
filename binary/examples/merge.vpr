import "../../_preambles/TrCloDomain.vpr"

import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


// import "../../_preambles/common/graph.vpr"

// import "../../_preambles/common/dag.vpr"
// import "../_preambles/dag.vpr"

define __CONVEXITY_CHECKES false 

define TREE(t) 
    GRAPH(t) && TREE_IMPL(t)

define TREE_IMPL(t)
    CLOSED(t) && ACYCLIC(t) //&& UNSHARED(t)

function subTree(t: Set[Ref], sub_root: Ref): Set[Ref]
    requires TREE(t)
    requires sub_root in t
    
    ensures result subset t
    ensures TREE_IMPL(result)
    ensures !(null in result)
    ensures sub_root in result
    ensures GLOBAL_ROOT(result, sub_root)
    // ensures result == subTree(result, sub_root)


method mergeRight(tree: Set[Ref], root: Ref, 
                 sub_tree:Set[Ref], root_s: Ref) 
                returns (new_tree: Set[Ref], 
                         linked_node: Ref) // ghost
    
    requires DISJOINT(tree, sub_tree)

    requires TREE(tree)
    requires root in tree
    requires GLOBAL_ROOT(tree, root)

    requires TREE(sub_tree)
    requires root_s in sub_tree
    requires GLOBAL_ROOT(sub_tree, root_s)

    ensures new_tree == tree union sub_tree
    ensures TREE(new_tree)
    ensures CONST_EDGES(sub_tree)

    ensures linked_node in tree 
    ensures forall x:Ref, y:Ref :: 
        { E_(new_tree, x, y) }
        { E0(tree, x, y) }
        { E0(sub_tree, x, y) }
            E_(new_tree, x, y) <==> E0(tree, x, y) || E0(sub_tree, x, y) || 
                                    (x == linked_node && y == root_s) 

    ensures old(root.right) == null ==> root == linked_node && root.right == root_s
    ensures GLOBAL_ROOT(new_tree, root)
    ensures forall n:Ref :: 
        { P_(new_tree, root, n) }
        { P0(sub_tree, root_s, n) }
        { P0(tree, root, n) }
            P_(new_tree, root, n) <==> P0(tree, root, n) || P0(sub_tree, root_s, n)

    // ensures forall x:Ref, y:Ref :: 
    //     { P_(new_tree, x, y) }
    //     { P0(tree, x, root), P0(new_tree, y, root_s) }
    //     { P0(tree, x, y) }
    //     { P0(sub_tree, x, y) }
    //         (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
    //         (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) &&
    //         (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) &&
    //         (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(new_tree, x, root) && P0(new_tree, root_s, y)))
{
    new_tree := tree union sub_tree

    if ( root.right != null ) {
        // assume false
        
        var ch_node:Ref := root.right
        var ch_tree: Set[Ref] := subTree(tree, ch_node)
        var frame: Set[Ref] := tree setminus ch_tree

        PartitionPathsInConvexSubHeap(tree, ch_tree)
        PartitionPathsInConvexSubHeap(tree, frame)
        
        var new_ch_tree: Set[Ref]
label l1
        new_ch_tree, linked_node := mergeRight(ch_tree, ch_node, sub_tree, root_s)
        assume forall x:Ref, y:Ref :: 
            { P_(new_ch_tree, x, y) }
            { P0(ch_tree, x, y) }
                 x in ch_tree && y in ch_tree &&
                    P0(ch_tree, x, y) ==> P_(new_ch_tree, x, y)
label l2

        new_tree := frame union new_ch_tree

        PartitionPathsInConvexSubHeap(new_tree, new_ch_tree)
        PartitionPathsInConvexSubHeap(new_tree, frame)
        // PartitionPathsInConvexSubHeap(new_tree, sub_tree)

        ApplyConvexTCFraming(l1, l2, new_ch_tree, new_tree)
        assume DISJOINT(frame, new_ch_tree)

        // assert GLOBAL_ROOT(new_ch_tree, ch_node)
        

        assert P_(new_tree, root, old(root.right))
        // // assert P_(new_tree, old(root.right), old(root.right))
        assert forall n:Ref :: 
            { P_(new_tree, root, n) }
                n in new_ch_tree ==> P_(new_tree, old(root.right), n)
        
        

        assert forall x:Ref, y:Ref :: 
            { P_(new_tree, x, y) }
            { P0(tree, x, y) }
                 x in tree && y in tree &&
                    P0(tree, x, y) ==> P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, y) }
        //          x in tree && y in tree ==> 
        //             (P_(new_tree, x, y) <==> P0(tree, x, y))


        assume false
    } else {
        assume false
        // PartitionPathsInConvexSubHeap(new_tree, tree)
        // PartitionPathsInConvexSubHeap(new_tree, sub_tree)

        // // Encoding root.right := root_s ...
        // link_DAG_right(new_tree, root, root_s)

        // // Ghost code for writing the postcondition
        // linked_node := root

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, y) }
        //          x in tree && y in tree ==> 
        //             (P_(new_tree, x, y) <==> P0(tree, x, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(sub_tree, x, y) }
        //          x in sub_tree && y in sub_tree ==> 
        //             (P_(new_tree, x, y) <==> P0(sub_tree, x, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //          x in sub_tree && y in tree ==> 
        //             !P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P_(new_tree, x, y) }
        //         (P_(new_tree, x, y) <==> 
        //             P0(new_tree, x, y) || 
        //             P0(new_tree, x, root) && P0(new_tree, root_s, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P0(new_tree, x, root) && P0(new_tree, y, root_s) ==> P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P0(tree, x, root) && P0(sub_tree, y, root_s) ==> P_(new_tree, x, y)
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree &&
        //          P_(new_tree, x, y) ==>
        //             P0(tree, x, root) //&& P0(sub_tree, y, root_s) 
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(new_tree, x, root), P0(new_tree, root_s, y) }
        //          x in tree && y in sub_tree ==>
        //             (P_(new_tree, x, y) == P0(new_tree, x, root) && P0(new_tree, root_s, y))
        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(new_tree, x, root), P0(sub_tree, root_s, y) }
        //          x in tree && y in sub_tree && P_(new_tree, x, y) ==> P0(sub_tree, root_s, y)


        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //          x in tree && y in sub_tree ==> 
        //             (P_(new_tree, x, y) <==> P0(new_tree, x, root) && P0(new_tree, root_s, y))

        // assert forall x:Ref, y:Ref :: 
        //     { P_(new_tree, x, y) }
        //     { P0(tree, x, root), P0(new_tree, y, root_s) }
        //     { P0(tree, x, y) }
        //     { P0(sub_tree, x, y) }
        //         (x in sub_tree && y in tree     ==> !P_(new_tree, x, y)) &&
        //         (x in sub_tree && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(sub_tree, x, y))) &&
        //         (x in tree     && y in tree     ==> (P_(new_tree, x, y) <==> P0(tree, x, y))) &&
        //         (x in tree     && y in sub_tree ==> (P_(new_tree, x, y) <==> P0(new_tree, x, root) && P0(new_tree, root_s, y)))
    }
}
