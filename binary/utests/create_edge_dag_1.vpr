import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"
import "../../_preambles/purification.vpr"
import "../../_preambles/framing.vpr"
import "../../_preambles/macros.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

method connect_DAGs(g0:Set[Ref], g1:Set[Ref], x0:Ref, x1:Ref, x:Ref)
    requires GRAPH(g0)
    requires acyclic(g0)
    requires x0 in g0
    requires x in g0

    requires GRAPH(g1)
    requires acyclic(g1)
    requires x1 in g1

    requires forall n:Ref :: { P(g0,x,n) } n in g0 ==> P(g0,x,n)
    requires forall n:Ref :: { P(g0,n,x0) } n in g0 ==> P(g0,n,x0)
    requires forall m:Ref :: { P(g1,x1,m) } m in g1 ==> P(g1,x1,m)

    requires x0.left == null || x0.right == null

    requires disjoint_sets(g0,g1)

{
    // The NoExit axiom applications can be inlined:
    // But now in Framing
    //assume forall u:Ref,v:Ref :: { exists_path($$(g0 union g1),u,v), u in g0, v in g0 } u in g0 && !(v in g0) ==> !exists_path($$(g0 union g1),u,v)
    //assume forall u:Ref,v:Ref :: { exists_path($$(g0 union g1),u,v), u in g1, v in g1 } u in g1 && !(v in g1) ==> !exists_path($$(g0 union g1),u,v)

    // do we really need both?
    assume apply_TCFraming(g0,g1)
    assume apply_TCFraming(g1,g0)

    assert acyclic(g0 union g1) //Needed for triggering?

    if ( x0.left == null ) {
        //x0.left := x1
        link_DAG_left(g0 union g1,x0,x1)
    } else {
        //x0.right := x1
        link_DAG_right(g0 union g1,x0,x1)
    }
    assume apply_TCFraming(g0,g1)
    assume apply_TCFraming(g1,g0)

    //Post conditions
    assert GRAPH(g0 union g1)
    assert forall n:Ref :: { P(g0 union g1,x,n) } n in (g0 union g1) ==> P(g0 union g1,x,n)

    assert acyclic(g0 union g1)


    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}