import "../../../_preambles/TrCloDomain.vpr"

import "../../../_preambles/framing.vpr"
import "../../../_preambles/legoFraming.vpr"

import "../../../_preambles/macros.vpr"
import "../../../_preambles/memspecs.vpr"
import "../../_preambles/memspecs.vpr"

define __CONVEXITY_CHECKES true

method callee(h: Set[Ref], s: Set[Ref]) 

    returns (new_h: Set[Ref])

    requires DISJOINT(h, s)

    requires GRAPH(h) 
    requires ACYCLIC(h)
    requires CLOSED(h)

    requires GRAPH(s) 
    requires ACYCLIC(s)
    requires CLOSED(s)
    
    ensures new_h == h union s
    ensures GRAPH(new_h)
    ensures ACYCLIC(new_h)
    ensures CLOSED(new_h)
    
method testSubProcMalloc(g: Set[Ref], g1: Set[Ref], s: Set[Ref]) 
    
    returns (new_g: Set[Ref])

    requires GRAPH(g) 
    requires g1 subset g
    requires CLOSED(g1)
    requires ACYCLIC(g) 

    requires DISJOINT(g, s)

    requires GRAPH(s) 
    requires ACYCLIC(s)
    requires CLOSED(s)


{
    var frame:Set[Ref] := g setminus g1

    PartitionPathsInConvexSubHeap(g, g1)
    PartitionPathsInConvexSubHeap(g, frame)

    var new_g1: Set[Ref] 

label l1
    new_g1 := callee(g1, s)
label l2

    // How can we get this? 
    // exhale GRAPH(frame)
    // exhale GRAPH(new_g1)

    new_g := frame union new_g1
    // assume DISJOINT(frame, new_g1)

    PartitionPathsInConvexSubHeap(new_g, new_g1)
    PartitionPathsInConvexSubHeap(new_g, frame)
    ApplyConvexTCFraming(l1, l2, new_g1, new_g)
    
    

    //// Out-In
    // Need to introduce the witness
    // TODO: is it okay to write the witness in terms of the old heap partitions? 
    var a:Ref 
    assume a in new_g1
    assume forall x:Ref, y:Ref :: 
        { P1(frame, x, a), P2(new_g1, a, y) }
            x in frame && y in new_g1 ==> 
                P1(frame, x, a) && P2(new_g1, a, y)

    assert ACYCLIC(new_g)
    
    // assert false
}


// method testDisjoint(g:Set[Ref], h:Set[Ref])
//     requires forall n:Ref :: { n.left } n in g ==> acc(n.left) 
//     // requires forall n:Ref :: { n.left } n in h ==> acc(n.left)
// {
//     exhale forall n:Ref :: { n.left } n in h ==> acc(n.left)
//     assert DISJOINT(g,h)
// }
