import "../../../_preambles/TrCloDomain.vpr"

import "../../../_preambles/framing.vpr"
import "../../../_preambles/legoFraming.vpr"

import "../../../_preambles/macros.vpr"
import "../../../_preambles/memspecs.vpr"
import "../../_preambles/memspecs.vpr"

method callee(h: Set[Ref], root_h: Ref, s: Set[Ref], root_s: Ref) 

    returns (new_h: Set[Ref])

    requires DISJOINT(h, s)

    requires GRAPH(h)
    requires ACYCLIC(h)
    requires CLOSED(h)
    requires root_h in h && GLOBAL_ROOT(h, root_h)

    requires GRAPH(s)
    requires ACYCLIC(s)
    requires CLOSED(s)
    requires root_s in s && GLOBAL_ROOT(s, root_s)
    
    ensures new_h == h union s
    ensures GRAPH(new_h)
    ensures ACYCLIC(new_h)
    ensures CLOSED(new_h)
    ensures GLOBAL_ROOT(new_h, root_h)

    ensures CONST_EDGES(s)

    ensures forall n:Ref :: 
        { P_(new_h, root_h, n) }
        { P0(h, root_h, n) }
        { P0(s, root_s, n) }
            n in new_h ==> 
                (P_(new_h, root_h, n) <==> P0(s, root_s, n) || P0(h, root_h, n))


method testSubProcMalloc(g: Set[Ref], s: Set[Ref], root_s: Ref) 
    
    returns (new_g: Set[Ref])

    requires GRAPH(g) 
    requires ACYCLIC(g) 

    requires DISJOINT(g, s)

    requires GRAPH(s) 
    requires ACYCLIC(s)
    requires CLOSED(s)
    requires root_s in s && GLOBAL_ROOT(s, root_s)

{
    var g1: Set[Ref] 
    var root_g1: Ref
    assume g1 subset g && CLOSED(g1) 
    assume root_g1 in g1
    assume GLOBAL_ROOT(g1, root_g1)

    var frame:Set[Ref] := g setminus g1

    PartitionPathsInConvexSubHeap(g, g1)
    PartitionPathsInConvexSubHeap(g, frame)
    // PartitionPathsInConvexSubHeap(g union s)

    var new_g1: Set[Ref] 

label l1
    new_g1 := callee(g1, root_g1, s, root_s)
label l2

    // How can we get this? 
    // exhale GRAPH(frame)
    // exhale GRAPH(new_g1)

    new_g := frame union new_g1


    PartitionPathsInConvexSubHeap(new_g, new_g1)
    PartitionPathsInConvexSubHeap(new_g, frame)
    PartitionPathsInConvexSubHeap(new_g, s)
    ApplyConvexTCFraming(l1, l2, new_g1, new_g)
    
    

    //// Out-In
    // Need to introduce the witness
    // TODO: is it okay to write the witness in terms of the old heap partitions? 
    //var a:Ref 
    // assume a in new_g1
    // assume forall x:Ref, y:Ref :: 
    //     { P1(frame, x, a), P2(new_g1, a, y) }
    //         x in frame && y in new_g1 ==> 
    //             P1(frame, x, a) && P2(new_g1, a, y)

    assert ACYCLIC(new_g)
    



    // assert forall n:Ref :: 
    //     // { P_(new_g1, root_g1, n) }
    //     // { P1(s, root_g1, n) }
    //     // { P1(s, root_s, n) }
    //     { dummy(n) }
    //         n in new_g && P1(s, root_g1, n) ==> P_(new_g1, root_g1, n)

    // assert forall n:Ref :: 
    //     { P_(new_g, root_g1, n) }
    //     { P1(s, root_g1, n) }
    //     { P1(s, root_s, n) }
    //         n in new_g1 && P1(s, root_s, n) ==> P_(new_g, root_g1, n)
    
    // // NoExit
    // assume (forall u0:Ref, v0:Ref :: 
    //     // { u0 in g1, v0 in frame }
    //     { P_(new_g, u0, v0) }
    //         u0 in new_g1 && !(v0 in new_g1) && CLOSED(new_g1)
    //             ==> !P_(new_g, u0, v0))


    assume DISJOINT(frame, new_g1)

    // assert forall v1:Ref, v2:Ref :: 
    //     { P_(new_g1, v1, v2) }
    //     { P_(new_g, v1, v2) }
    //         v1 in frame && v1 != v2 ==> !P_(new_g1, v1, v2)

    // assert forall n:Ref :: 
    //     { P_(new_g1, root_s, n) }
    //     { P_(new_g, root_s, n) }
    //         root_s in frame && root_s != n ==> !P_(new_g1, root_s, n)

    // assert forall n:Ref :: 
    //     { P_(new_g1, root_s, n) }
    //     { P_(new_g, root_s, n) }
    //         root_s in frame ==> !P_(new_g1, root_s, n)

    // assert (forall u0:Ref, v0:Ref :: 
    //     { P_(new_g, u0, v0) }
    //         u0 in new_g1 && !(v0 in new_g1) && CLOSED(new_g1)
    //             ==> !P_(new_g, u0, v0))

    // assert CLOSED(new_g1)

    // assert (forall n:Ref :: 
    //     { P_(new_g, root_s, n) }
    //          n in frame ==> !P_(new_g, root_s, n))

    // assert (forall v1:Ref, v2:Ref :: 
    //     { P_(new_g1, v1, v2) }
    //     { P_(new_g, v1, v2) }
    //         (v1 in new_g1) && 
    //         (v2 in frame) ==> 
    //             (P_(new_g1, v1, v2) ==> P_(new_g, v1, v2)))

    // assert (forall v1:Ref, v2:Ref :: 
    //     { P_(new_g1, v1, v2) }
    //     { P_(new_g, v1, v2) }
    //         (v1 in new_g1) && 
    //         (v2 in frame) ==> 
    //             (!P_(new_g, v1, v2) ==> !P_(new_g1, v1, v2)))

    // assert (forall n:Ref :: 
    //     { P_(new_g1, root_s, n) }
    //     { P_(new_g, root_s, n) }
    //         (n in frame) ==> 
    //             (!P_(new_g, root_s, n) ==> !P_(new_g1, root_s, n)))

    
    // assert (forall n:Ref :: 
    //     { P_(new_g, root_s, n) }
    //     { P_(new_g1, root_s, n) }
    //          n in frame ==> !P_(new_g1, root_s, n))

    // assert (forall n:Ref :: 
    //     { P_(new_g, root_s, n) }
    //     { P_(s, root_s, n) }
    //          n in frame ==> !P_(s, root_s, n))

    // assert forall n:Ref :: 
    //     { P_(new_g, root_g1, n) }
    //     { P1(s, root_g1, n) }
    //     { P1(s, root_s, n) }
    //         n in frame ==> !P2(new_g, root_s, n) 

    // TODO
    // assume forall n:Ref :: 
    //     { P_(new_g, root_g1, n) }
    //     { P1(s, root_g1, n) }
    //     { P1(s, root_s, n) }
    //         n in frame ==> !P1(new_g, root_s, n) 

    // assert forall n:Ref :: 
    //     { P_(new_g, root_g1, n) }
    //     { P1(s, root_g1, n) }
    //     { P1(s, root_s, n) }
    //         n in frame &&
    //             P1(s, root_s, n) ==> P_(new_g, root_g1, n)



    // assert forall n:Ref :: 
    //     { P_(new_g, root_g1, n) }
    //     { P1(s, root_g1, n) }
    //     { P1(s, root_s, n) }
    //         n in new_g ==> 
    //             (P1(s, root_g1, n) || P1(s, root_s, n) ==> P_(new_g, root_g1, n))


    // Overall proof goal
    assert forall n:Ref :: 
        { P_(new_g, root_g1, n) }
        { P1(s, root_g1, n) }
        { P1(s, root_s, n) }
            n in new_g ==> 
                (P_(new_g, root_g1, n) <==> P1(s, root_s, n) || P1(g1, root_g1, n))

}


// method testDisjoint(g:Set[Ref], h:Set[Ref])
//     requires forall n:Ref :: { n.left } n in g ==> acc(n.left) 
//     // requires forall n:Ref :: { n.left } n in h ==> acc(n.left)
// {
//     exhale forall n:Ref :: { n.left } n in h ==> acc(n.left)
//     assert DISJOINT(g,h)
// }


// function dummy(bla: Ref): Bool
//     ensures result == true