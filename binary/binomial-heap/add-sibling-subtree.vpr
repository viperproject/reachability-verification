import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"

import "../../_preambles/framing.vpr"
import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

define child left 
define next_sibling right

method addSiblingSubtree(tree: Set[Ref], node: Ref, 
                         sub_tree:Set[Ref], sib: Ref) returns (new_tree: Set[Ref])
    
    requires DISJOINT(tree, sub_tree)

    requires GRAPH(tree) && CLOSED(tree)
    requires node in tree
    requires ACYCLIC(tree)
    requires UNSHARED(tree)
    
    requires GRAPH(sub_tree) && CLOSED(sub_tree)
    requires sib in sub_tree
    requires ACYCLIC(sub_tree)
    requires UNSHARED(sub_tree)
    requires GLOBAL_ROOT(sub_tree, sib)
    requires forall n:Ref :: 
        { P_(sub_tree, n, sib) }
            n in sub_tree && P_(sub_tree, n, sib) ==> n == sib

    ensures new_tree == tree union sub_tree
    ensures GRAPH(new_tree) && CLOSED(new_tree)
    ensures ACYCLIC(new_tree)
    ensures $$(sub_tree) == old($$(sub_tree))
    ensures GLOBAL_ROOT(sub_tree, sib)
    ensures UNSHARED(new_tree)
    ensures forall n:Ref :: 
        { P0(tree, node, n) }
            n in new_tree && P0(tree, node, n) ==> P_(new_tree, node, n)
    ensures forall n:Ref :: 
        { P0(tree, node, n) }
            n in sub_tree ==> P_(new_tree, node, n)
{
    var curr_node: Ref := node
    while ( curr_node.next_sibling != null )
        invariant GRAPH(tree) && CLOSED(tree)
        invariant node in tree && curr_node in tree

        invariant GRAPH(sub_tree) && CLOSED(sub_tree)
        invariant sib in sub_tree

        invariant DISJOINT(tree, sub_tree)

        invariant $$(tree) == old($$(tree))
        invariant $$(sub_tree) == old($$(sub_tree))

        invariant curr_node.next_sibling != null ==> P_(tree, curr_node, curr_node.next_sibling)
        invariant P_(tree, node, curr_node)

        invariant forall n:Ref :: 
            { P_(tree, node, n) }
            { P0(tree, node, n) }
                n in tree && !P0(tree, node, n) ==> !P_(tree, node, n)

        invariant forall n:Ref :: 
            { P0(tree, node, n) }
                n in tree && P0(tree, node, n) ==> P_(tree, node, n)

        invariant ACYCLIC(tree)
        invariant UNSHARED(tree)

        invariant ACYCLIC(sub_tree)
        invariant UNSHARED(sub_tree)
        invariant GLOBAL_ROOT(sub_tree, sib)
        invariant forall n:Ref :: 
            { P_(sub_tree, n, sib) }
                n in sub_tree && P_(sub_tree, n, sib) ==> n == sib
    {
        curr_node := curr_node.next_sibling
    }
   
    new_tree := tree union sub_tree
    
    // Framing
    assume apply_TCFraming(tree, sub_tree)

    //curr_node.next_sibling := sib
    link_DAG_right(new_tree, curr_node, sib)
}
