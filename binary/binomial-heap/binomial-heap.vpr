import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"

import "../../_preambles/framing.vpr"
import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"


// function getRootKey(binTree: Set[Ref]): Int
//     requires GRAPH(binTree)

// method mergeTree(p: Set[Ref], q: Set[Ref]) returns (r: Set[Ref])
//     requires GRAPH(p) && CLOSED(p)
//     requires GRAPH(q) && CLOSED(q)
//     requires DISJOINT(p,q)
// {
//     r := p union q

//     var p_root_key: Int := getRootKey(p)
//     var q_root_key: Int := getRootKey(q)

//     if ( p_root_key <= q_root_key ) {
        
//     } else {

//     }
// }

// method addSubTree(p: Set[Ref], q: Set[Ref]) returns (r: Set[Ref])
// {

// }

define child left 
define next_sibling right

// method kthChild(tree: Set[Ref], n: Ref, k: Int) returns (res: Ref)
//     requires GRAPH(tree) && CLOSED(tree)
//     requires n in tree
//     requires P(tree, )
// {
//     var i: Int := k
//     res := n.child
//     while ( i != 0 && res != null )
//         invariant GRAPH(tree) && CLOSED(tree)
//         invariant res != null ==> res in tree
//     {
//         res := res.next_sibling
//         i := i - 1
//     }
// }

method addSiblingSubtree(tree: Set[Ref], node: Ref, 
                         sub_tree:Set[Ref], sib: Ref) returns (new_tree: Set[Ref])
    
    requires DISJOINT(tree, sub_tree)

    requires GRAPH(tree) && CLOSED(tree)
    requires node in tree
    requires ACYCLIC(tree)
    requires UNSHARED(tree)
    
    requires GRAPH(sub_tree) && CLOSED(sub_tree)
    requires sib in sub_tree
    requires ACYCLIC(sub_tree)
    requires UNSHARED(sub_tree)
    requires GLOBAL_ROOT(sub_tree, sib)
    requires forall n:Ref :: 
        { P_(sub_tree, n, sib) }
            n in sub_tree && P_(sub_tree, n, sib) ==> n == sib

    ensures new_tree == tree union sub_tree
    ensures GRAPH(new_tree) && CLOSED(new_tree)
    ensures ACYCLIC(new_tree)
    ensures $$(sub_tree) == old($$(sub_tree))
    ensures GLOBAL_ROOT(sub_tree, sib)
    ensures UNSHARED(new_tree)
    ensures forall n:Ref :: 
        { P0(tree, node, n) }
            n in new_tree && P0(tree, node, n) ==> P_(new_tree, node, n)
    ensures forall n:Ref :: 
        { P0(tree, node, n) }
            n in sub_tree ==> P_(new_tree, node, n)