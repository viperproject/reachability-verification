import "../../_preambles/TrCloDomain.vpr"
import "../../_preambles/TrCloZopgDomain.vpr"

import "../../_preambles/legoFraming.vpr"

import "../../_preambles/macros.vpr"
import "../../_preambles/memspecs.vpr"
import "../_preambles/memspecs.vpr"


import "../../_preambles/common/graph.vpr"

import "../../_preambles/common/dag.vpr"
import "../_preambles/dag.vpr"

define child left 
define next_sibling right

// method kthChild(tree: Set[Ref], n: Ref, k: Int) returns (res: Ref)
//     requires GRAPH(tree) && CLOSED(tree)
//     requires n in tree
//     requires P(tree, )
// {
//     var i: Int := k
//     res := n.child
//     while ( i != 0 && res != null )
//         invariant GRAPH(tree) && CLOSED(tree)
//         invariant res != null ==> res in tree
//     {
//         res := res.next_sibling
//         i := i - 1
//     }
// }

method addSibling(tree: Set[Ref], node: Ref, ch: Ref) returns (new_tree: Set[Ref])
    requires GRAPH(tree) && CLOSED(tree)
    requires node in tree
    requires !(ch in tree) && ch != null && acc(ch.child) && acc(ch.next_sibling) 
    // make sure the sibling is not attached to anything yet
    requires ch.child == null && ch.next_sibling == null 
    requires ACYCLIC(tree)
    requires UNSHARED(tree)

    ensures GRAPH(new_tree) && CLOSED(new_tree)
    ensures ACYCLIC(new_tree)
    ensures UNSHARED(new_tree)
    ensures forall n:Ref :: 
        { P0(tree, node, n) }
            n in new_tree && P0(tree, node, n) ==> P_(new_tree, node, n)
{
    var curr_node: Ref := node
    while ( curr_node.next_sibling != null )
        invariant GRAPH(tree) && CLOSED(tree)
        invariant node in tree && curr_node in tree

        invariant $$(tree) == old($$(tree))

        invariant curr_node.next_sibling != null ==> P_(tree, curr_node, curr_node.next_sibling)
        invariant P_(tree, node, curr_node)

        invariant forall n:Ref :: 
            { P_(tree, node, n) }
            { P0(tree, node, n) }
                n in tree && !P0(tree, node, n) ==> !P_(tree, node, n)

        invariant forall n:Ref :: 
            { P0(tree, node, n) }
                n in tree && P0(tree, node, n) ==> P_(tree, node, n)

        invariant ACYCLIC(tree)
        invariant UNSHARED(tree)
    {
        curr_node := curr_node.next_sibling
    }
   
    new_tree := tree union Set(ch)
    
    // Framing
    assume forall x:Ref, y:Ref :: 
        { P_(new_tree, x, y) } 
        { P_(tree, x, y) }
        { P_(tree union Set( ch ), x, y) }
            x in tree && y in tree ==> ( P_(tree, x, y) <==> P_(new_tree, x, y) )
    assume forall x:Ref, y:Ref :: 
        { E_(new_tree, x, y) } 
        { E_(tree, x, y) }
        { E_(tree union Set( ch ), x, y) }
            x in tree && y in tree ==> ( E_(new_tree, x, y) <==> E_(tree, x, y) )
    // NoExit
    assume forall n:Ref :: 
        { P_(new_tree, n, ch) }
            n in new_tree && n != ch ==> !P_(new_tree, n, ch)
    assume forall n:Ref :: 
        { P_(new_tree, n, ch) }
            n in new_tree && n != ch ==> !P_(new_tree, ch, n)

    //curr_node.next_sibling := ch
    link_DAG_right(new_tree, curr_node, ch)
}
