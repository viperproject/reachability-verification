// Overlapping Purification: 
//  only the beginning of the edges and paths is in the set; 
//  the ends may or may not be in the set. 
//  This may be useful for framing. 
function $$(nodes0: Set[Ref]): Set[Edge]
    requires READONLY_NODES(nodes0)
    ensures (forall x0: Ref, y0: Ref :: 
        { create_edge(x0, y0) } 
            ((x0 in nodes0) && (CLOSED(nodes0) ==> y0 in nodes0) && HEAP_PARTIAL_ORDER(x0,y0)) <==> (create_edge(x0, y0) in result))
    /*ensures (forall x0: Ref, y0: Ref :: 
        { (x0 in nodes0),(y0 in nodes0), exists_path(result, x0, y0) }
            (x0 in nodes0) && exists_path(result, x0, y0) ==> (y0 in nodes0))*/
    ensures (forall x0: Ref, y0: Ref :: 
        { (x0 in nodes0),(y0 in nodes0), exists_path(result, x0, y0) } 
            (y0 in nodes0) && exists_path(result, x0, y0) ==> (x0 in nodes0))


define CONVEX(state, local_nodes, global_nodes)
    (local_nodes subset global_nodes) && 
    (forall v1:Ref, v2:Ref, u:Ref :: 
        { P(state, local_nodes, v1, u), P(state, local_nodes, u, v2) } 
            v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
                !(P(state, global_nodes, v1, u) && P(state, global_nodes, u, v2)))

// define CONVEX(local_nodes, global_nodes)
//     (local_nodes subset global_nodes) && 
//     (forall v1:Ref, v2:Ref, u:Ref :: 
//         { P(local_nodes, v1, u), P(local_nodes, u, v2) } 
//             v1 in local_nodes && v2 in local_nodes && !(u in local_nodes) && u in global_nodes ==> 
//                 !(P(global_nodes, v1, u) && P(global_nodes, u, v2)))

define ConvexTCFraming(s_old, s_new, MOD, GLOB) {
    assume (let FRAME==(GLOB setminus MOD) in 
        (forall x0:Ref, y0:Ref :: 
            { P_(GLOB, x0, y0) }
            { P(s_new, GLOB, x0, y0) } 
            { P(s_old, GLOB, x0, y0) } 
            { P(s_new, MOD, x0, y0) }
                // I. In-In
                (x0 in MOD) && (y0 in MOD) ==> (
                    P(s_new, MOD, x0, y0) <==> P(s_new, GLOB, x0, y0)
                )) && 
        (forall x0:Ref, y0:Ref :: 
            { P_(GLOB, x0, y0) }
            { P(s_new, GLOB, x0, y0) } 
            { P(s_old, GLOB, x0, y0) } 
                // II. Out-In
                (x0 in FRAME) && (y0 in MOD) ==> (
                    !(forall alpha:Ref :: 
                        { P(s_old, FRAME, x0, alpha) }
                        { P(s_new, MOD, alpha, y0) }
                            (alpha in MOD) ==> 
                                !( P(s_old, FRAME, x0, alpha) && P(s_new, MOD, alpha, y0) ))
                    <==> P(s_new, GLOB, x0, y0)
                )) && 
        (forall x0:Ref, y0:Ref :: 
            { P_(GLOB, x0, y0) }
            { P(s_new, GLOB, x0, y0) } 
            { P(s_old, GLOB, x0, y0) } 
                // III. In-Out
                (x0 in MOD) && (y0 in FRAME) ==> (
                    !(forall beta:Ref :: 
                        { P(s_new, MOD, x0, beta) }
                        { P(s_old, GLOB, beta, y0) }
                            (beta in FRAME) ==> 
                                !( P(s_new, MOD, x0, beta) && P(s_old, GLOB, beta, y0) ))
                    <==> P(s_new, GLOB, x0, y0)
                )) &&
        (forall x0:Ref, y0:Ref :: 
            { P_(GLOB, x0, y0) }
            { P(s_new, GLOB, x0, y0) } 
            { P(s_old, GLOB, x0, y0) } 
                // IV. Out-Out
                (x0 in FRAME) && (y0 in FRAME) ==> (
                    P(s_old, FRAME, x0, y0) || 
                    !(forall alpha:Ref, beta:Ref :: 
                        { P(s_new, MOD, alpha, beta) }
                        { P(s_old, FRAME, x0, alpha), P(s_old, FRAME, beta, y0) } 
                            (alpha in MOD) && (beta in FRAME) ==> 
                                !( P(s_old, FRAME, x0, alpha) && P(s_new, MOD, alpha, beta) && P(s_old, FRAME, beta, y0) ))
                    <==> P(s_new, GLOB, x0, y0)
                )))
}

// To be applied before a method call. 
define __Split_P__(GLOB, MOD, FRAME_1, FRAME_2) {
    //assert GLOB == DISJOINT_UNION(MOD, FRAME_1, FRAME_2)
    //assert DISJOINT(MOD, FRAME_1, FRAME_2)
    //assert CONVEX_TRIPLE(MOD, FRAME_1, FRAME_2)

    // (a)    P(g, _, _) <~~~> P(mod, _, _)
    assume forall v1:Ref, v2:Ref :: 
        { P_(g1, v1, v2) }
            (v1 in MOD) && (v2 in MOD) ==> (
                P_(GLOB, v1, v2) <==> P_(MOD, v1, v2))

    // assume forall v1:Ref, u:Ref, v2:Ref :: 
    //     { P_(GLOB, v1, u), E_(GLOB, u, v2) }
    //     { P_(GLOB, v1, u), P_(MOD, v1, v2) }
    //     { E_(GLOB, u, v2), P_(MOD, v1, v2) }
    //         (v1 in MOD) && 
    //         (u in MOD) &&
    //         !(v2 in MOD) && (v2 in GLOB) ==> (
    //             P_(GLOB, v1, u) && E_(GLOB, u, v2) ==> P_(MOD, v1, v2))

    assume forall v1:Ref, v2:Ref :: 
        { P_(MOD, v1, v2) }
        { P_(GLOB, v1, v2) }
            (v1 in MOD) && 
            !(v2 in MOD) && (v2 in GLOB) ==> (
                P_(MOD, v1, v2) ==> P_(GLOB, v1, v2))


    // assume forall v1:Ref, u:Ref, v2:Ref :: 
    //     { P_(GLOB, v1, u), E_(GLOB, u, v2) }
    //     { P_(GLOB, v1, u), P_(GLOB setminus MOD, v1, v2) }
    //     { E_(GLOB, u, v2), P_(GLOB setminus MOD, v1, v2) }
    //         (v1 in GLOB setminus MOD) && 
    //         (u in GLOB setminus MOD) &&
    //         (v2 in MOD) ==> (
    //             P_(GLOB, v1, u) && E_(GLOB, u, v2) ==> P_(GLOB setminus MOD, v1, v2))

    assume forall v1:Ref, v2:Ref :: 
        { P_(MOD, v1, v2) }
        { P_(GLOB, v1, v2) }
            (v1 in GLOB setminus MOD) && 
            (v2 in MOD) ==> (
                P_(GLOB setminus MOD, v1, v2) ==> P_(GLOB, v1, v2))


    // P(g, _, _) <~~~> P(frame, _, _)
    assume forall v1:Ref, v2:Ref :: 
        { P_(g1, v1, v2) }
            (v1 in GLOB setminus MOD) && (v2 in GLOB setminus MOD) ==> (
                P_(GLOB, v1, v2) <==> P_(GLOB setminus MOD, v1, v2))

}

/** Intended way of using these formulas: 

    @mod g
    {
label l1
        // { Assumptions about P1(g, _, _) }

        __Split_P__(g1, g)

        call m1()
            @mod g1
            ensures // { P2(g1, _, _) <==> ... }

label l2
        assume ConvexTCFraming(l1, l2, g1, g)
        
        // { Assertions about P2(g, _, _) }
    }
 */