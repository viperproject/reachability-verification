/**
    Framing formulas taken from https://people.cs.umass.edu/~immerman/pub/POPL2014.pdf
 */

define tmp(graph_A, graph_B, u0, v0)
    ( forall alpha:Ref, beta:Ref :: 
                { P(graph_A, u0, alpha), P(graph_A, beta, v0) }
                { P(graph_A union graph_B, alpha, beta) }
                    (alpha in graph_A) && (beta in graph_A) ==> 
                        !P(graph_A, u0, alpha) 
                        || !P(graph_A union graph_B, alpha, beta) //Don't we first need negative framing before talking about negative paths in the union graph?
                        || !P(graph_A, beta, v0))

function apply_TCFraming(graph_A:Set[Ref], graph_B:Set[Ref]): Bool
    requires READONLY_NODES(graph_A)
    requires READONLY_NODES(graph_B)

    requires graph_B intersection graph_A == Set()

    // needed for triggering
    ensures graph_A union graph_B == graph_B union graph_A

    // FIXME: Triggers in the following formulas are under question.
    ensures (forall u0:Ref, v0:Ref :: 
        { P(graph_A, u0, v0) }
        { P(graph_A union graph_B, u0, v0) } 
            u0 in graph_A && v0 in graph_A && P(graph_A, u0, v0) ==> P(graph_A union graph_B, u0, v0))
    
    ensures (forall u0:Ref, v0:Ref :: 
        { P(graph_B, u0, v0) }
        { P(graph_B union graph_A, u0, v0) } 
            u0 in graph_B && v0 in graph_B && P(graph_B, u0, v0) ==> P(graph_B union graph_A, u0, v0))
    
    ensures (forall u0:Ref, v0:Ref :: 
        { P(graph_A, u0, v0) }
        { P(graph_A union graph_B, u0, v0) } 
            !P(graph_A, u0, v0) && u0 in graph_A && v0 in graph_A
            && (tmp(graph_A, graph_B, u0, v0) || 
                single_direction_paths(graph_A, graph_B))             
            ==> !P(graph_A union graph_B, u0, v0))

    ensures (forall u0:Ref, v0:Ref :: 
        { P(graph_B, u0, v0) }
        { P(graph_B union graph_A, u0, v0) } 
            !P(graph_B, u0, v0) && u0 in graph_B && v0 in graph_B
            && (tmp(graph_B, graph_A, u0, v0) || 
                single_direction_paths(graph_A, graph_B))             
            ==> !P(graph_B union graph_A, u0, v0))

    ensures ( forall u:Ref,v:Ref :: { P(graph_A union graph_B,u,v), u in graph_A, v in graph_A }
         u in graph_A && !(v in graph_A) && CLOSED(graph_A)
            ==> !P(graph_A union graph_B,u,v) )

    ensures ( forall u:Ref,v:Ref :: { P(graph_A union graph_B,u,v), u in graph_B, v in graph_B }
         u in graph_B && !(v in graph_B) && CLOSED(graph_B) 
             ==> !P(graph_A union graph_B,u,v) )
