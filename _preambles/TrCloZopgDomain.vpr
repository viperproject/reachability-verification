domain ZeroOnePathGraphTCs {

    function DEP(EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref): Bool
    function DEP_alias(EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref): Bool

    //TODO: Rename quantified variables 
    axiom ax_DEP_alias {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
                DEP(EG,x,y,u,v) <==> DEP_alias(EG,x,y,u,v)
    }

    // axiom ax_DEP_0 { -- somehow, it also causes unsoundness...
    //     forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
    //         { DEP(EG,x,y,u,v) }
    //         { exists_path(EG,x,u), exists_path(EG,v,y) }
    //             exists_path_(EG,x,u) && edge(EG,u,v) && exists_path_(EG,v,y) ==> DEP_alias(EG,x,y,u,v)
    // }

    //TODO: Rename quantified variables 
    axiom ax_DEP_0_2 {
        forall EG:Set[Edge], x:Ref, y:Ref ::
            { DEP(EG,x,y,x,y) }
            { edge(EG,x,y) }
                edge(EG, x, y) && x != y <==> DEP_alias(EG,x,y,x,y)
    }

    //TODO: Rename quantified variables 
    axiom ax_HeadTriangleImposable {
        forall EG:Set[Edge], x:Ref, y:Ref, v:Ref ::
            { DEP(EG,x,y,x,v) }
            { exists_path_(EG,x,y), exists_path(EG,v,y) }
            { edge(EG,x,v), exists_path(EG,v,y) }
                /*exists_path_(EG,x,y) &&*/ edge(EG,x,v)  && x != v && exists_path_(EG,v,y) ==> DEP_alias(EG,x,y,x,v)
    }

    //TODO: Rename quantified variables 
    axiom ax_TailTriangleImposable {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref ::
            { DEP(EG,x,y,u,y) }
            { exists_path_(EG,x,y), exists_path(EG,x,u) }
            { edge(EG,u,y), exists_path(EG,x,u) }
                /*exists_path_(EG,x,y) &&*/ exists_path_(EG,x,u) && edge(EG,u,y) && u != y ==> DEP_alias(EG,x,y,u,y)
    }

    //TODO: Rename quantified variables 
    axiom ax_NoEdgeNoDEP {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
                // Consider replacing LHS with (!edge(EG,u,v) && u != v)
                !edge(EG,u,v) || u == v ==> !DEP_alias(EG,x,y,u,v)
    }

    //TODO: Rename quantified variables 
    /*axiom ax_TriangleImposable_Neg {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
            //{ exists_path_(EG,x,y), exists_path(EG,v,y) }
            //{ edge(EG,x,v), exists_path_(EG,v,y) }
                //BLABLA BLA exists_path_(EG,x,y) && edge(EG,x,v) && exists_path_(EG,v,y) ==> !DEP_alias(EG,x,y,u,v)
    }*/

    
    /*axiom ax_DEP_0_1 {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
            { exists_path(EG,x,u), exists_path(EG,v,y) }
                exists_path(EG,x,u) && edge(EG,u,v) && exists_path(EG,v,y) ==> DEP(EG,x,y,u,v)
    }*/

    /*axiom ax_DEP_1 { -- incorrect
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
            { exists_path(EG,x,u), exists_path(EG,v,y) }
                DEP(EG,x,y,u,v) <==> exists_path(EG,x,u) && edge(EG,u,v) && exists_path(EG,v,y)
    }*/

    /*axiom ax_DEP_2 { -- also incorrect
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG,x,y,u,v) }
            { exists_path(EG,x,y), edge(EG,u,v) }
                DEP(EG,x,y,u,v) <==> exists_path(EG,x,y) && edge(EG,u,v)
    }*/

    // axiom ax_DEP_3 {
    //     forall EG:Set[Edge], x:Ref, y:Ref ::
    //         { exists_path(EG,x,y) }
    //             exists_path_(EG,x,y) <==>
    //                 x == y ||
    //                     !forall u:Ref, v:Ref ::
    //                         { DEP(EG,x,y,u,v) }
    //                         { exists_path(EG,x,y), edge(EG,u,v) }
    //                             !DEP_alias(EG,x,y,u,v)
    // }
    /*
    axiom ax_DEP_4 {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            //{ DEP(EG,x,y,u,v) }
            { exists_path(EG,x,y), edge(EG,u,v) }
            { exists_path(EG,x,y), exists_path(EG,u,v) }
                DEP_alias(EG,x,y,u,v) ==> exists_path_(EG,x,y) && edge_(EG,u,v)
    }*/

    /*axiom ax_DEP_5 { less general than ax_DEP_3
        forall EG:Set[Edge], u:Ref, v:Ref ::
            { exists_path(EG,u,v) }
                !exists_path_(EG,u,v) ==> forall x:Ref, y:Ref :: { DEP(EG,x,y,u,v) } !DEP_alias(EG,x,y,u,v)
    }*/

    //TODO: Rename quantified variables 
    axiom ax_DEP_trigger_magic {
        forall EG:Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG, x, y, u, v) }
                DEP(EG, x, y, u, v) ==> exists_path(EG, x, y) && edge(EG, u, v) && u != v
    }

    //TODO: Rename quantified variables 
    axiom ax_DEP_6_head { // could be a cool lemma that needs a cool proof! :-)
        forall EG:Set[Edge], x:Ref, y:Ref, n:Ref ::
            { DEP(EG, y, n, x, y) }
                /*edge(EG, x, y) &&*/ n != y ==> !DEP_alias(EG, y, n, x, y)
    }

    //TODO: Rename quantified variables 
    axiom ax_DEP_6_tail { // could be a cool lemma that needs a cool proof! :-)
        forall EG:Set[Edge], x:Ref, y:Ref, n:Ref ::
            { DEP(EG, n, x, x, y) }
                /*edge(EG, x, y) &&*/ n != x ==> !DEP_alias(EG, n, x, x, y)
    }

    //TODO: Rename quantified variables 
    axiom ax_DEP_7 {
        forall EG:Set[Edge], nu:Ref, n:Ref, mu:Ref, sigma:Ref ::
            { DEP(EG, nu, n, mu, sigma) }
                nu != n && n != sigma && nu != mu && edge(EG, nu, sigma) && edge(EG, mu, sigma)
                    ==> !DEP_alias(EG, nu, n, mu, sigma) || mu == sigma
    }

    /* -- Isn't being triggered without the right term. (Needs manual assertions?)
    axiom ax_UnrollFromHead {
        forall EG:Set[Edge], x:Ref, y:Ref, n:Ref ::
            //{ exists_path(EG, x, n), edge(EG, x, y) }
            { DEP(EG, x, n, x, y) }
                DEP(EG, x, n, x, y) ==> exists_path(EG, x, n)
    }*/
    
    //TODO: Rename quantified variables 
    axiom ax_DepNeedsCoAlignedPathAndEdge {
        forall EG: Set[Edge], x:Ref, y:Ref, u:Ref, v:Ref ::
            { DEP(EG, x, y, u, v) } 
            { exists_path(EG, x, u), exists_path(EG, v, y) }
                !exists_path_(EG, x, u) || !exists_path_(EG, v, y) ==> !DEP_alias(EG, x, y, u, v)
    }
}

